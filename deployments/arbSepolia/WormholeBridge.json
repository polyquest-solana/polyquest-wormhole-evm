{
  "address": "0x6dFbA3394EE4Cf592c2aD72712DE9892F0aa1433",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_wormhole",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_tokenBridge",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_wormholeRelayer",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_circleIntegration",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "SafeERC20FailedOperation",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint16",
          "name": "sourceChain",
          "type": "uint16"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "sourceAddress",
          "type": "bytes32"
        }
      ],
      "name": "ReceiveMessage",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "TransferToken",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "CONSISTENCY_LEVEL",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "GAS_LIMIT",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MESSAGE_TIME_OUT_SECONDS",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "circleIntegration",
      "outputs": [
        {
          "internalType": "contract ICircleIntegration",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "encodedMessage",
          "type": "bytes"
        }
      ],
      "name": "decodePayload",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint8",
              "name": "payloadID",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "recipient",
              "type": "bytes32"
            }
          ],
          "internalType": "struct WormholeBridge.TokenTransfer",
          "name": "parsedMessage",
          "type": "tuple"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getMessageFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "tokenAddress",
          "type": "bytes32"
        },
        {
          "internalType": "uint16",
          "name": "sourceChain",
          "type": "uint16"
        }
      ],
      "name": "getSourceAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getWormholeChainId",
      "outputs": [
        {
          "internalType": "uint16",
          "name": "",
          "type": "uint16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "policy",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pullPolicy",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newPolicy_",
          "type": "address"
        }
      ],
      "name": "pushPolicy",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "targetChain",
          "type": "uint16"
        }
      ],
      "name": "quoteEVMDeliveryCost",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "cost",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_whMessage",
          "type": "bytes"
        }
      ],
      "name": "receiveSolanaMessage",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "payload",
          "type": "bytes"
        },
        {
          "internalType": "bytes[]",
          "name": "",
          "type": "bytes[]"
        },
        {
          "internalType": "bytes32",
          "name": "sourceAddress",
          "type": "bytes32"
        },
        {
          "internalType": "uint16",
          "name": "sourceChain",
          "type": "uint16"
        },
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "receiveWormholeMessages",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "encodedVM",
          "type": "bytes"
        }
      ],
      "name": "redeemTransferWithPayload",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "sourceChain",
          "type": "uint16"
        },
        {
          "internalType": "bytes32",
          "name": "sourceAddress",
          "type": "bytes32"
        }
      ],
      "name": "registerSender",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "relayer",
      "outputs": [
        {
          "internalType": "contract IWormholeRelayer",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renouncePolicy",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_bettingToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_marketId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_answerId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_bettingKey",
          "type": "uint256"
        },
        {
          "internalType": "uint16",
          "name": "targetChain",
          "type": "uint16"
        },
        {
          "internalType": "address",
          "name": "targetAddress",
          "type": "address"
        }
      ],
      "name": "sendMessageToEvm",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_bettingToken",
          "type": "address"
        },
        {
          "internalType": "uint64",
          "name": "_amount",
          "type": "uint64"
        },
        {
          "internalType": "uint64",
          "name": "_marketId",
          "type": "uint64"
        },
        {
          "internalType": "uint64",
          "name": "_answerId",
          "type": "uint64"
        }
      ],
      "name": "sendMessageToSolana",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "sequence",
          "type": "uint64"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "tokenBridge",
      "outputs": [
        {
          "internalType": "contract ITokenBridge",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_recipient",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_bettingToken",
          "type": "address"
        },
        {
          "internalType": "uint64",
          "name": "_amount",
          "type": "uint64"
        },
        {
          "internalType": "uint16",
          "name": "_targetChain",
          "type": "uint16"
        },
        {
          "internalType": "bytes32",
          "name": "_targetAddress",
          "type": "bytes32"
        }
      ],
      "name": "transferCrossChain",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "wormhole",
      "outputs": [
        {
          "internalType": "contract IWormhole",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x411fa5e5cdfb67464b696e26ef7fa4682e3de8e505189eaf98acbc9b14c424c9",
  "receipt": {
    "to": null,
    "from": "0x595622cBd0Fc4727DF476a1172AdA30A9dDf8F43",
    "contractAddress": "0x6dFbA3394EE4Cf592c2aD72712DE9892F0aa1433",
    "transactionIndex": 2,
    "gasUsed": "2563411",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000800000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000020000000000000000000800000000000000000000000000000000400000000000000000000000002000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000020000000000000000000000000000000000000000000000001000000000000000000",
    "blockHash": "0x1322045b62afb813ceaaf7bd1a123f5f3863a1a02953612b0c60a9ba89f5db17",
    "transactionHash": "0x411fa5e5cdfb67464b696e26ef7fa4682e3de8e505189eaf98acbc9b14c424c9",
    "logs": [
      {
        "transactionIndex": 2,
        "blockNumber": 112691194,
        "transactionHash": "0x411fa5e5cdfb67464b696e26ef7fa4682e3de8e505189eaf98acbc9b14c424c9",
        "address": "0x6dFbA3394EE4Cf592c2aD72712DE9892F0aa1433",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000595622cbd0fc4727df476a1172ada30a9ddf8f43"
        ],
        "data": "0x",
        "logIndex": 0,
        "blockHash": "0x1322045b62afb813ceaaf7bd1a123f5f3863a1a02953612b0c60a9ba89f5db17"
      }
    ],
    "blockNumber": 112691194,
    "cumulativeGasUsed": "2588202",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x6b9C8671cdDC8dEab9c719bB87cBd3e782bA6a35",
    "0xC7A204bDBFe983FCD8d8E61D02b475D4073fF97e",
    "0x7B1bD7a6b4E61c2a123AC6BC2cbfC614437D0470",
    "0x2703483B1a5a7c577e8680de9Df8Be03c6f30e3c"
  ],
  "numDeployments": 1,
  "solcInputHash": "ea7886e897d37c1d922ca82bdadafa0b",
  "metadata": "{\"compiler\":{\"version\":\"0.8.27+commit.40a35a09\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wormhole\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenBridge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wormholeRelayer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_circleIntegration\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"sourceChain\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"sourceAddress\",\"type\":\"bytes32\"}],\"name\":\"ReceiveMessage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferToken\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CONSISTENCY_LEVEL\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GAS_LIMIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MESSAGE_TIME_OUT_SECONDS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"circleIntegration\",\"outputs\":[{\"internalType\":\"contract ICircleIntegration\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedMessage\",\"type\":\"bytes\"}],\"name\":\"decodePayload\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"payloadID\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"recipient\",\"type\":\"bytes32\"}],\"internalType\":\"struct WormholeBridge.TokenTransfer\",\"name\":\"parsedMessage\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMessageFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"tokenAddress\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"sourceChain\",\"type\":\"uint16\"}],\"name\":\"getSourceAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWormholeChainId\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"policy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pullPolicy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPolicy_\",\"type\":\"address\"}],\"name\":\"pushPolicy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"targetChain\",\"type\":\"uint16\"}],\"name\":\"quoteEVMDeliveryCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_whMessage\",\"type\":\"bytes\"}],\"name\":\"receiveSolanaMessage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes32\",\"name\":\"sourceAddress\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"sourceChain\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"receiveWormholeMessages\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedVM\",\"type\":\"bytes\"}],\"name\":\"redeemTransferWithPayload\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"sourceChain\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"sourceAddress\",\"type\":\"bytes32\"}],\"name\":\"registerSender\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relayer\",\"outputs\":[{\"internalType\":\"contract IWormholeRelayer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePolicy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bettingToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_answerId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bettingKey\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"targetChain\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"}],\"name\":\"sendMessageToEvm\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bettingToken\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_amount\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_marketId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_answerId\",\"type\":\"uint64\"}],\"name\":\"sendMessageToSolana\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"sequence\",\"type\":\"uint64\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenBridge\",\"outputs\":[{\"internalType\":\"contract ITokenBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bettingToken\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_amount\",\"type\":\"uint64\"},{\"internalType\":\"uint16\",\"name\":\"_targetChain\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"_targetAddress\",\"type\":\"bytes32\"}],\"name\":\"transferCrossChain\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wormhole\",\"outputs\":[{\"internalType\":\"contract IWormhole\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"SafeERC20FailedOperation(address)\":[{\"details\":\"An operation with an ERC-20 token failed.\"}]},\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"MESSAGE_TIME_OUT_SECONDS()\":{\"notice\":\"Message timeout in seconds: Time out needs to account for: - Finality time on source chain - Time for Wormhole validators to sign and make VAA available to relayers - Time to relay VAA to the target chain - Congestion on target chain leading to delayed inclusion of transaction in target chain Note that there is no way to alter this hard coded value. Including such a feature would require some governance structure and some minumum and maximum values.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/WormholeBridge.sol\":\"WormholeBridge\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":0},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/interfaces/IERC1363.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1363.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @title IERC1363\\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\\n *\\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\\n */\\ninterface IERC1363 is IERC20, IERC165 {\\n    /*\\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\\n     * 0xb0202a11 ===\\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\\n     */\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferAndCall(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @param data Additional data with no specified format, sent in call to `to`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param from The address which you want to send tokens from.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param from The address which you want to send tokens from.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @param data Additional data with no specified format, sent in call to `to`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function approveAndCall(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     * @param data Additional data with no specified format, sent in call to `spender`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9b6b3e7803bc5f2f8cd7ad57db8ac1def61a9930a5a3107df4882e028a9605d7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../utils/introspection/IERC165.sol\\\";\\n\",\"keccak256\":\"0xde7e9fd9aee8d4f40772f96bb3b58836cbc6dfc0227014a061947f8821ea9724\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../token/ERC20/IERC20.sol\\\";\\n\",\"keccak256\":\"0xce41876e78d1badc0512229b4d14e4daf83bc1003d7f83978d18e0e56f965b9c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-20 standard as defined in the ERC.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\",\"keccak256\":\"0xe06a3f08a987af6ad2e1c1e774405d4fe08f1694b67517438b467cecf0da0ef7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\nimport {IERC1363} from \\\"../../../interfaces/IERC1363.sol\\\";\\nimport {Address} from \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    /**\\n     * @dev An operation with an ERC-20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Indicates a failed `decreaseAllowance` request.\\n     */\\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     *\\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \\\"client\\\"\\n     * smart contract uses ERC-7674 to set temporary allowances, then the \\\"client\\\" smart contract should avoid using\\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\\n     * value, non-reverting calls are assumed to be successful.\\n     *\\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \\\"client\\\"\\n     * smart contract uses ERC-7674 to set temporary allowances, then the \\\"client\\\" smart contract should avoid using\\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance < requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     *\\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\\n     * only sets the \\\"standard\\\" allowance. Any temporary allowance will remain active, in addition to the value being\\n     * set here.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\\n        if (to.code.length == 0) {\\n            safeTransfer(token, to, value);\\n        } else if (!token.transferAndCall(to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function transferFromAndCallRelaxed(\\n        IERC1363 token,\\n        address from,\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal {\\n        if (to.code.length == 0) {\\n            safeTransferFrom(token, from, to, value);\\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\\n     * once without retrying, and relies on the returned value to be true.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\\n        if (to.code.length == 0) {\\n            forceApprove(token, to, value);\\n        } else if (!token.approveAndCall(to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly (\\\"memory-safe\\\") {\\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\\n            // bubble errors\\n            if iszero(success) {\\n                let ptr := mload(0x40)\\n                returndatacopy(ptr, 0, returndatasize())\\n                revert(ptr, returndatasize())\\n            }\\n            returnSize := returndatasize()\\n            returnValue := mload(0)\\n        }\\n\\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly (\\\"memory-safe\\\") {\\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0)\\n        }\\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\\n    }\\n}\\n\",\"keccak256\":\"0xca2ae13e0610f6a99238dd00b97bd786bc92732dae6d6b9d61f573ec51018310\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Errors} from \\\"./Errors.sol\\\";\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert Errors.InsufficientBalance(address(this).balance, amount);\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert Errors.FailedCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {Errors.FailedCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert Errors.InsufficientBalance(address(this).balance, value);\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\\n     * of an unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {Errors.FailedCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            assembly (\\\"memory-safe\\\") {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert Errors.FailedCall();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9d8da059267bac779a2dbbb9a26c2acf00ca83085e105d62d5d4ef96054a47f5\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of common custom errors used in multiple contracts\\n *\\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\\n * It is recommended to avoid relying on the error API for critical functionality.\\n *\\n * _Available since v5.1._\\n */\\nlibrary Errors {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error InsufficientBalance(uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedCall();\\n\\n    /**\\n     * @dev The deployment failed.\\n     */\\n    error FailedDeployment();\\n\\n    /**\\n     * @dev A necessary precompile is missing.\\n     */\\n    error MissingPrecompile(address);\\n}\\n\",\"keccak256\":\"0x6afa713bfd42cf0f7656efa91201007ac465e42049d7de1d50753a373648c123\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x79796192ec90263f21b464d5bc90b777a525971d3de8232be80d9c4f9fb353b8\",\"license\":\"MIT\"},\"contracts/Policy.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity ^0.8.27;\\r\\nimport \\\"./interfaces/IPolicy.sol\\\";\\r\\n\\r\\ncontract Policy is IPolicy {\\r\\n    \\r\\n    address internal _policy;\\r\\n    address internal _newPolicy;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    constructor () {\\r\\n        _policy = msg.sender;\\r\\n        emit OwnershipTransferred( address(0), _policy );\\r\\n    }\\r\\n\\r\\n    function policy() public view override returns (address) {\\r\\n        return _policy;\\r\\n    }\\r\\n\\r\\n    modifier onlyPolicy() {\\r\\n        require( _policy == msg.sender, \\\"Ownable: caller is not the owner\\\" );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function renouncePolicy() public virtual override onlyPolicy() {\\r\\n        emit OwnershipTransferred( _policy, address(0) );\\r\\n        _policy = address(0);\\r\\n    }\\r\\n\\r\\n    function pushPolicy( address newPolicy_ ) public virtual override onlyPolicy() {\\r\\n        require( newPolicy_ != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _newPolicy = newPolicy_;\\r\\n    }\\r\\n\\r\\n    function pullPolicy() public virtual override {\\r\\n        require( msg.sender == _newPolicy );\\r\\n        emit OwnershipTransferred( _policy, _newPolicy );\\r\\n        _policy = _newPolicy;\\r\\n    }\\r\\n}\",\"keccak256\":\"0x1ca4a586c068bb23836cbf4cfad535225c6ddfb63ae6ce7d7b612be7cdb58255\",\"license\":\"AGPL-3.0-or-later\"},\"contracts/WormholeBridge.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\r\\npragma solidity ^0.8.27;\\r\\n\\r\\nimport \\\"./interfaces/IWormhole.sol\\\";\\r\\nimport \\\"./Policy.sol\\\";\\r\\nimport \\\"./libraries/BytesLib.sol\\\";\\r\\nimport \\\"./interfaces/ITokenBridge.sol\\\";\\r\\nimport \\\"./interfaces/IWormholeRelayer.sol\\\";\\r\\nimport \\\"./interfaces/IWormholeReceiver.sol\\\";\\r\\nimport \\\"./interfaces/ICircleIntegration.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\r\\n\\r\\ncontract WormholeBridge is Policy, IWormholeReceiver {\\r\\n    using SafeERC20 for IERC20;\\r\\n    using BytesLib for bytes;\\r\\n\\r\\n    uint32 private NONCE;\\r\\n    uint8 public constant CONSISTENCY_LEVEL = 200;\\r\\n    uint256 public constant GAS_LIMIT = 1_000_000;\\r\\n    uint64 private minSequence = 0;\\r\\n    /**\\r\\n     * Message timeout in seconds: Time out needs to account for:\\r\\n     * - Finality time on source chain\\r\\n     * - Time for Wormhole validators to sign and make VAA available to relayers\\r\\n     * - Time to relay VAA to the target chain\\r\\n     * - Congestion on target chain leading to delayed inclusion of transaction in target chain\\r\\n     *\\r\\n     * Note that there is no way to alter this hard coded value. Including such a feature\\r\\n     * would require some governance structure and some minumum and maximum values.\\r\\n     */\\r\\n    uint256 public constant MESSAGE_TIME_OUT_SECONDS = 2 days;\\r\\n\\r\\n    IWormhole public immutable wormhole;\\r\\n    ITokenBridge public immutable tokenBridge;\\r\\n    IWormholeRelayer public immutable relayer;\\r\\n    ICircleIntegration public immutable circleIntegration;\\r\\n    mapping(address => mapping (address => uint256)) locked;\\r\\n    mapping(uint16 => bytes32) registeredSenders;\\r\\n\\r\\n    struct Message {\\r\\n        uint8 payloadID;\\r\\n        bytes message;\\r\\n    }\\r\\n\\r\\n    struct TokenTransfer {\\r\\n        uint8 payloadID;\\r\\n        bytes32 recipient;\\r\\n    }\\r\\n\\r\\n    event TransferToken(address indexed token, uint256 amount);\\r\\n    event ReceiveMessage(address sender, uint16 sourceChain, bytes32 sourceAddress);\\r\\n\\r\\n    constructor(address _wormhole, address _tokenBridge, address _wormholeRelayer, address _circleIntegration) Policy() {\\r\\n        require(_wormhole != address(0), \\\"ZA\\\");\\r\\n        wormhole = IWormhole(_wormhole);\\r\\n        require(_tokenBridge != address(0), \\\"ZA\\\");\\r\\n        tokenBridge = ITokenBridge(_tokenBridge);\\r\\n        relayer = IWormholeRelayer(_wormholeRelayer);\\r\\n        circleIntegration = ICircleIntegration(_circleIntegration);\\r\\n        NONCE = 0;\\r\\n    }\\r\\n\\r\\n    modifier onlyRelayer() {\\r\\n        require(msg.sender == address(relayer), \\\"Not relayer\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // Modifier to check if the sender is registered for the source chain\\r\\n    modifier isRegisteredSender(uint16 sourceChain, bytes32 sourceAddress) {\\r\\n        require(registeredSenders[sourceChain] == sourceAddress, \\\"Not registered sender\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // Function to register the valid sender address for a specific chain\\r\\n    function registerSender(uint16 sourceChain, bytes32 sourceAddress) external onlyPolicy {\\r\\n        registeredSenders[sourceChain] = sourceAddress;\\r\\n    }\\r\\n\\r\\n    function sendMessageToSolana(\\r\\n        address _bettingToken,\\r\\n        uint64 _amount,\\r\\n        uint64 _marketId,\\r\\n        uint64 _answerId\\r\\n    ) external payable returns(uint64 sequence) {\\r\\n        uint256 messageFee = wormhole.messageFee();\\r\\n        require(msg.value >= messageFee, \\\"Insufficient funds for cross-chain delivery\\\");\\r\\n        IERC20(_bettingToken).safeTransferFrom(msg.sender, address(this), _amount);\\r\\n        locked[msg.sender][_bettingToken] = _amount;\\r\\n        bytes memory messagePayload = abi.encodePacked(\\r\\n            _marketId,\\r\\n            _answerId,\\r\\n            uint64(block.timestamp),\\r\\n            wormhole.chainId(),\\r\\n            bytes32(bytes20(msg.sender)),\\r\\n            bytes32(bytes20(_bettingToken)),\\r\\n            _amount\\r\\n        );\\r\\n        Message memory parsedMessage = Message({\\r\\n            payloadID: 1,\\r\\n            message: messagePayload\\r\\n        });\\r\\n\\r\\n        bytes memory encodeMessage = abi.encodePacked(\\r\\n            parsedMessage.payloadID,\\r\\n            uint16(parsedMessage.message.length),\\r\\n            parsedMessage.message\\r\\n        );\\r\\n\\r\\n        sequence = wormhole.publishMessage{value: messageFee}(\\r\\n            NONCE++, \\r\\n            encodeMessage,\\r\\n            CONSISTENCY_LEVEL\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function receiveSolanaMessage(bytes calldata _whMessage) external payable {\\r\\n        (IWormhole.VM memory vm, bool valid, string memory reason) = wormhole.parseAndVerifyVM(_whMessage);\\r\\n        require(valid, reason);\\r\\n        require(registeredSenders[vm.emitterChainId] == vm.emitterAddress, \\\"Invalid Emitter Address!\\\");\\r\\n\\r\\n        /**\\r\\n         * Ensure that the sequence field in the VAA is strictly monotonically increasing. This also acts as\\r\\n         * a replay protection mechanism to ensure that already executed messages don't execute again.\\r\\n         */\\r\\n        require(vm.sequence >= minSequence, \\\"Invalid Sequence number\\\");\\r\\n        minSequence = vm.sequence + 1;\\r\\n\\r\\n        // check if the message is still valid as defined by the validity period\\r\\n        // solhint-disable-next-line not-rely-on-time\\r\\n        require(vm.timestamp + MESSAGE_TIME_OUT_SECONDS >= block.timestamp, \\\"Message no longer valid\\\");\\r\\n\\r\\n        (\\r\\n            address voter,\\r\\n            address bettingToken,\\r\\n            uint256 amount,\\r\\n            uint16 receiverChainId,\\r\\n            bytes32 receiverAddress\\r\\n        ) = abi.decode(vm.payload, (address, address, uint256, uint16, bytes32));\\r\\n        require(receiverChainId == wormhole.chainId(), \\\"Wrong chain Id\\\");\\r\\n        require(receiverAddress == bytes32(bytes20(address(this))), \\\"Wrong address\\\");\\r\\n\\r\\n        uint256 lockedAmount = locked[voter][bettingToken];\\r\\n        require(lockedAmount >= amount, \\\"Invalid amount\\\");\\r\\n        locked[voter][bettingToken] -= amount;\\r\\n        IERC20(bettingToken).safeTransfer(voter, amount);\\r\\n        emit TransferToken(bettingToken, amount);\\r\\n    }\\r\\n\\r\\n    function sendMessageToEvm(\\r\\n        address _bettingToken,\\r\\n        uint256 _amount,\\r\\n        uint256 _marketId,\\r\\n        uint256 _answerId,\\r\\n        uint256 _bettingKey,\\r\\n        uint16 targetChain,\\r\\n        address targetAddress    \\r\\n    ) external payable {\\r\\n        (uint256 cost, ) = relayer.quoteEVMDeliveryPrice(targetChain, 0, GAS_LIMIT); // Dynamically calculate the cross-chain cost\\r\\n        require(msg.value >= cost, \\\"Insufficient funds for cross-chain delivery\\\");\\r\\n\\r\\n        bytes memory messagePayload = abi.encode(\\r\\n            _marketId,\\r\\n            _answerId,\\r\\n            _bettingKey,\\r\\n            block.timestamp,\\r\\n            bytes32(bytes20(msg.sender)),\\r\\n            bytes32(bytes20(_bettingToken)),\\r\\n            _amount\\r\\n        );\\r\\n        relayer.sendPayloadToEvm{value: cost}(\\r\\n            targetChain,\\r\\n            targetAddress,\\r\\n            abi.encode(messagePayload, msg.sender), // Payload contains the message and sender address\\r\\n            0, // No receiver value needed\\r\\n            GAS_LIMIT // Gas limit for the transaction\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function receiveWormholeMessages(\\r\\n    bytes memory payload,\\r\\n    bytes[] memory,\\r\\n    bytes32 sourceAddress,\\r\\n    uint16 sourceChain,\\r\\n    bytes32\\r\\n  ) external payable onlyRelayer isRegisteredSender(sourceChain, sourceAddress) {\\r\\n    (, , , , bytes32 voter, , ) = abi.decode(payload, (uint256, uint256, uint256, uint256, bytes32, bytes32, uint256));\\r\\n    emit ReceiveMessage(address(uint160(uint256(voter))), sourceChain, sourceAddress);\\r\\n  }\\r\\n\\r\\n    function transferCrossChain(\\r\\n        address _recipient, \\r\\n        address _bettingToken, \\r\\n        uint64 _amount,\\r\\n        uint16 _targetChain,\\r\\n        bytes32 _targetAddress\\r\\n    ) external payable {\\r\\n        uint256 messageFee = wormhole.messageFee();\\r\\n        require(msg.value >= messageFee, \\\"Invalid msg value\\\");\\r\\n        IERC20(_bettingToken).safeTransferFrom(msg.sender, address(this), _amount);        \\r\\n        tokenBridge.transferTokensWithPayload(\\r\\n            _bettingToken,\\r\\n            _amount,\\r\\n            _targetChain,\\r\\n            _targetAddress,\\r\\n            NONCE,\\r\\n            abi.encode(_recipient)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function redeemTransferWithPayload(bytes memory encodedVM) public {\\r\\n        IWormhole.VM memory vm = wormhole.parseVM(\\r\\n            encodedVM\\r\\n        );\\r\\n\\r\\n        ITokenBridge.TransferWithPayload memory transfer = tokenBridge.parseTransferWithPayload(vm.payload);\\r\\n        address localTokenAddress = tokenBridge.wrappedAsset(transfer.tokenChain, transfer.tokenAddress);\\r\\n        if(transfer.tokenChain == 1 && localTokenAddress == address(0)) {\\r\\n            bytes32 usdcAddress = circleIntegration.fetchLocalTokenAddress(5, transfer.tokenAddress);\\r\\n            localTokenAddress = address(uint160(uint256(usdcAddress)));\\r\\n        }\\r\\n        require(localTokenAddress != address(0), \\\"token not attested\\\");\\r\\n\\r\\n        tokenBridge.completeTransferWithPayload(\\r\\n            encodedVM\\r\\n        );\\r\\n        uint256 amountTransferred = transfer.amount;\\r\\n\\r\\n        require(registeredSenders[vm.emitterChainId] == vm.emitterAddress, \\\"Invalid Emitter Address!\\\");\\r\\n\\r\\n        TokenTransfer memory payload = decodePayload(\\r\\n            transfer.payload\\r\\n        );\\r\\n\\r\\n        address recipient = address(uint160(uint256(payload.recipient)));\\r\\n        IERC20(localTokenAddress).safeTransfer(\\r\\n            recipient,\\r\\n            amountTransferred\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function decodePayload(\\r\\n        bytes memory encodedMessage\\r\\n    ) public pure returns (TokenTransfer memory parsedMessage) {\\r\\n        uint256 index = 0;\\r\\n        parsedMessage.payloadID = encodedMessage.toUint8(index);\\r\\n        require(parsedMessage.payloadID == 1, \\\"invalid payloadID\\\");\\r\\n        index += 1;\\r\\n        parsedMessage.recipient = encodedMessage.toBytes32(index);\\r\\n        index += 32;\\r\\n        require(index == encodedMessage.length, \\\"invalid payload length\\\");\\r\\n    }\\r\\n\\r\\n    function quoteEVMDeliveryCost(uint16 targetChain) external view returns(uint256 cost) {\\r\\n        (cost, ) = relayer.quoteEVMDeliveryPrice(targetChain, 0, GAS_LIMIT);\\r\\n    }\\r\\n    function getMessageFee() external view returns(uint256) {\\r\\n        return wormhole.messageFee();\\r\\n    }\\r\\n\\r\\n    function getWormholeChainId() external view returns(uint16) {\\r\\n        return wormhole.chainId();\\r\\n    }\\r\\n\\r\\n    function getSourceAddress(bytes32 tokenAddress, uint16 sourceChain) external view returns(address) {\\r\\n        uint32 sourceDomain = circleIntegration.getDomainFromChainId(sourceChain);\\r\\n        return address(uint160(uint256(circleIntegration.fetchLocalTokenAddress(sourceDomain, tokenAddress))));\\r\\n    }\\r\\n}\",\"keccak256\":\"0xda295fe39dd63ebf34349c436f18bc5bb64bded9bf4f46e8843d0058285339b5\",\"license\":\"Apache-2.0\"},\"contracts/interfaces/ICircleBridge.sol\":{\"content\":\"// SPDX-License-Identifier: Apache 2\\r\\npragma solidity ^0.8.19;\\r\\n\\r\\nimport {IMessageTransmitter} from \\\"./IMessageTransmitter.sol\\\";\\r\\nimport {ITokenMinter} from \\\"./ITokenMinter.sol\\\";\\r\\n\\r\\ninterface ICircleBridge {\\r\\n    /**\\r\\n     * @notice Deposits and burns tokens from sender to be minted on destination domain.\\r\\n     * Emits a `DepositForBurn` event.\\r\\n     * @dev reverts if:\\r\\n     * - given burnToken is not supported\\r\\n     * - given destinationDomain has no CircleBridge registered\\r\\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\\r\\n     * to this contract is less than `amount`.\\r\\n     * - burn() reverts. For example, if `amount` is 0.\\r\\n     * - MessageTransmitter returns false or reverts.\\r\\n     * @param _amount amount of tokens to burn\\r\\n     * @param _destinationDomain destination domain (ETH = 0, AVAX = 1)\\r\\n     * @param _mintRecipient address of mint recipient on destination domain\\r\\n     * @param _burnToken address of contract to burn deposited tokens, on local domain\\r\\n     * @return _nonce unique nonce reserved by message\\r\\n     */\\r\\n    function depositForBurn(uint256 _amount, uint32 _destinationDomain, bytes32 _mintRecipient, address _burnToken)\\r\\n        external\\r\\n        returns (uint64 _nonce);\\r\\n\\r\\n    /**\\r\\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\\r\\n     * on the destination domain must be called by `_destinationCaller`.\\r\\n     * WARNING: if the `_destinationCaller` does not represent a valid address as bytes32, then it will not be possible\\r\\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\\r\\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\\r\\n     * Emits a `DepositForBurn` event.\\r\\n     * @dev reverts if:\\r\\n     * - given destinationCaller is zero address\\r\\n     * - given burnToken is not supported\\r\\n     * - given destinationDomain has no CircleBridge registered\\r\\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\\r\\n     * to this contract is less than `amount`.\\r\\n     * - burn() reverts. For example, if `amount` is 0.\\r\\n     * - MessageTransmitter returns false or reverts.\\r\\n     * @param _amount amount of tokens to burn\\r\\n     * @param _destinationDomain destination domain\\r\\n     * @param _mintRecipient address of mint recipient on destination domain\\r\\n     * @param _burnToken address of contract to burn deposited tokens, on local domain\\r\\n     * @param _destinationCaller caller on the destination domain, as bytes32\\r\\n     * @return _nonce unique nonce reserved by message\\r\\n     */\\r\\n    function depositForBurnWithCaller(\\r\\n        uint256 _amount,\\r\\n        uint32 _destinationDomain,\\r\\n        bytes32 _mintRecipient,\\r\\n        address _burnToken,\\r\\n        bytes32 _destinationCaller\\r\\n    ) external returns (uint64 _nonce);\\r\\n\\r\\n    function owner() external view returns (address);\\r\\n\\r\\n    function handleReceiveMessage(uint32 _remoteDomain, bytes32 _sender, bytes memory messageBody)\\r\\n        external\\r\\n        view\\r\\n        returns (bool);\\r\\n\\r\\n    function localMessageTransmitter() external view returns (IMessageTransmitter);\\r\\n\\r\\n    function localMinter() external view returns (ITokenMinter);\\r\\n\\r\\n    function remoteCircleBridges(uint32 domain) external view returns (bytes32);\\r\\n\\r\\n    // owner only methods\\r\\n    function transferOwnership(address newOwner) external;\\r\\n}\",\"keccak256\":\"0x447384cab8e14dc1c257c10d9600dcb767c117792eba87b202744423ee50eb4d\",\"license\":\"Apache 2\"},\"contracts/interfaces/ICircleIntegration.sol\":{\"content\":\"// SPDX-License-Identifier: Apache 2\\r\\n\\r\\npragma solidity ^0.8.19;\\r\\n\\r\\nimport {IWormhole} from \\\"./IWormhole.sol\\\";\\r\\nimport {ICircleBridge} from \\\"./ICircleBridge.sol\\\";\\r\\nimport {IMessageTransmitter} from \\\"./IMessageTransmitter.sol\\\";\\r\\n\\r\\ninterface ICircleIntegration {\\r\\n    struct TransferParameters {\\r\\n        address token;\\r\\n        uint256 amount;\\r\\n        uint16 targetChain;\\r\\n        bytes32 mintRecipient;\\r\\n    }\\r\\n\\r\\n    struct RedeemParameters {\\r\\n        bytes encodedWormholeMessage;\\r\\n        bytes circleBridgeMessage;\\r\\n        bytes circleAttestation;\\r\\n    }\\r\\n\\r\\n    struct DepositWithPayload {\\r\\n        bytes32 token;\\r\\n        uint256 amount;\\r\\n        uint32 sourceDomain;\\r\\n        uint32 targetDomain;\\r\\n        uint64 nonce;\\r\\n        bytes32 fromAddress;\\r\\n        bytes32 mintRecipient;\\r\\n        bytes payload;\\r\\n    }\\r\\n\\r\\n    function transferTokensWithPayload(TransferParameters memory transferParams, uint32 batchId, bytes memory payload)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint64 messageSequence);\\r\\n\\r\\n    function redeemTokensWithPayload(RedeemParameters memory params)\\r\\n        external\\r\\n        returns (DepositWithPayload memory depositWithPayload);\\r\\n\\r\\n    function fetchLocalTokenAddress(uint32 sourceDomain, bytes32 sourceToken)\\r\\n        external\\r\\n        view\\r\\n        returns (bytes32);\\r\\n\\r\\n    function encodeDepositWithPayload(DepositWithPayload memory message) external pure returns (bytes memory);\\r\\n\\r\\n    function decodeDepositWithPayload(bytes memory encoded) external pure returns (DepositWithPayload memory message);\\r\\n\\r\\n    function isInitialized(address impl) external view returns (bool);\\r\\n\\r\\n    function wormhole() external view returns (IWormhole);\\r\\n\\r\\n    function chainId() external view returns (uint16);\\r\\n\\r\\n    function wormholeFinality() external view returns (uint8);\\r\\n\\r\\n    function circleBridge() external view returns (ICircleBridge);\\r\\n\\r\\n    function circleTransmitter() external view returns (IMessageTransmitter);\\r\\n\\r\\n    function getRegisteredEmitter(uint16 emitterChainId) external view returns (bytes32);\\r\\n\\r\\n    function isAcceptedToken(address token) external view returns (bool);\\r\\n\\r\\n    function getDomainFromChainId(uint16 chainId_) external view returns (uint32);\\r\\n\\r\\n    function getChainIdFromDomain(uint32 domain) external view returns (uint16);\\r\\n\\r\\n    function isMessageConsumed(bytes32 hash) external view returns (bool);\\r\\n\\r\\n    function localDomain() external view returns (uint32);\\r\\n\\r\\n    function verifyGovernanceMessage(bytes memory encodedMessage, uint8 action)\\r\\n        external\\r\\n        view\\r\\n        returns (bytes32 messageHash, bytes memory payload);\\r\\n\\r\\n    function evmChain() external view returns (uint256);\\r\\n\\r\\n    // guardian governance only\\r\\n    function updateWormholeFinality(bytes memory encodedMessage) external;\\r\\n\\r\\n    function registerEmitterAndDomain(bytes memory encodedMessage) external;\\r\\n\\r\\n    function upgradeContract(bytes memory encodedMessage) external;\\r\\n}\",\"keccak256\":\"0xc87916364c5158e5d51196f3ab06f9299a641f65203436e973edeca7102fe4d8\",\"license\":\"Apache 2\"},\"contracts/interfaces/IMessageTransmitter.sol\":{\"content\":\"// SPDX-License-Identifier: Apache 2\\r\\npragma solidity ^0.8.19;\\r\\n\\r\\ninterface IMessageTransmitter {\\r\\n    event MessageSent(bytes message);\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted when tokens are minted\\r\\n     * @param _mintRecipient recipient address of minted tokens\\r\\n     * @param _amount amount of minted tokens\\r\\n     * @param _mintToken contract address of minted token\\r\\n     */\\r\\n    event MintAndWithdraw(address _mintRecipient, uint256 _amount, address _mintToken);\\r\\n\\r\\n    /**\\r\\n     * @notice Receive a message. Messages with a given nonce\\r\\n     * can only be broadcast once for a (sourceDomain, destinationDomain)\\r\\n     * pair. The message body of a valid message is passed to the\\r\\n     * specified recipient for further processing.\\r\\n     *\\r\\n     * @dev Attestation format:\\r\\n     * A valid attestation is the concatenated 65-byte signature(s) of exactly\\r\\n     * `thresholdSignature` signatures, in increasing order of attester address.\\r\\n     * ***If the attester addresses recovered from signatures are not in\\r\\n     * increasing order, signature verification will fail.***\\r\\n     * If incorrect number of signatures or duplicate signatures are supplied,\\r\\n     * signature verification will fail.\\r\\n     *\\r\\n     * Message format:\\r\\n     * Field Bytes Type Index\\r\\n     * version 4 uint32 0\\r\\n     * sourceDomain 4 uint32 4\\r\\n     * destinationDomain 4 uint32 8\\r\\n     * nonce 8 uint64 12\\r\\n     * sender 32 bytes32 20\\r\\n     * recipient 32 bytes32 52\\r\\n     * messageBody dynamic bytes 84\\r\\n     * @param _message Message bytes\\r\\n     * @param _attestation Concatenated 65-byte signature(s) of `_message`, in increasing order\\r\\n     * of the attester address recovered from signatures.\\r\\n     * @return success bool, true if successful\\r\\n     */\\r\\n    function receiveMessage(bytes memory _message, bytes calldata _attestation) external returns (bool success);\\r\\n\\r\\n    function attesterManager() external view returns (address);\\r\\n\\r\\n    function availableNonces(uint32 domain) external view returns (uint64);\\r\\n\\r\\n    function getNumEnabledAttesters() external view returns (uint256);\\r\\n\\r\\n    function isEnabledAttester(address _attester) external view returns (bool);\\r\\n\\r\\n    function localDomain() external view returns (uint32);\\r\\n\\r\\n    function maxMessageBodySize() external view returns (uint256);\\r\\n\\r\\n    function owner() external view returns (address);\\r\\n\\r\\n    function paused() external view returns (bool);\\r\\n\\r\\n    function pauser() external view returns (address);\\r\\n\\r\\n    function rescuer() external view returns (address);\\r\\n\\r\\n    function version() external view returns (uint32);\\r\\n\\r\\n    // owner only methods\\r\\n    function transferOwnership(address newOwner) external;\\r\\n\\r\\n    function updateAttesterManager(address _newAttesterManager) external;\\r\\n\\r\\n    // attester manager only methods\\r\\n    function getEnabledAttester(uint256 _index) external view returns (address);\\r\\n\\r\\n    function disableAttester(address _attester) external;\\r\\n\\r\\n    function enableAttester(address _attester) external;\\r\\n\\r\\n    function setSignatureThreshold(uint256 newSignatureThreshold) external;\\r\\n}\",\"keccak256\":\"0xd592ff36eb7c2b7a81d1048af173231749b3ed6c4f43832e50e16407608f195f\",\"license\":\"Apache 2\"},\"contracts/interfaces/IPolicy.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity ^0.8.27;\\r\\ninterface IPolicy {\\r\\n\\r\\n    function policy() external view returns (address);\\r\\n\\r\\n    function renouncePolicy() external;\\r\\n  \\r\\n    function pushPolicy( address newPolicy_ ) external;\\r\\n\\r\\n    function pullPolicy() external;\\r\\n}\",\"keccak256\":\"0x93da3a9527ad11607cf07ae107c30bc94bfdf06af08e3b7637820f9a64c0a2ed\",\"license\":\"AGPL-3.0-or-later\"},\"contracts/interfaces/ITokenBridge.sol\":{\"content\":\"// SPDX-License-Identifier: Apache 2\\r\\n\\r\\npragma solidity ^0.8.27;\\r\\n\\r\\nimport \\\"./IWETH.sol\\\";\\r\\nimport \\\"./IWormhole.sol\\\";\\r\\n\\r\\ninterface ITokenBridge {\\r\\n    struct Transfer {\\r\\n        uint8 payloadID;\\r\\n        uint256 amount;\\r\\n        bytes32 tokenAddress;\\r\\n        uint16 tokenChain;\\r\\n        bytes32 to;\\r\\n        uint16 toChain;\\r\\n        uint256 fee;\\r\\n    }\\r\\n\\r\\n    struct TransferWithPayload {\\r\\n        uint8 payloadID;\\r\\n        uint256 amount;\\r\\n        bytes32 tokenAddress;\\r\\n        uint16 tokenChain;\\r\\n        bytes32 to;\\r\\n        uint16 toChain;\\r\\n        bytes32 fromAddress;\\r\\n        bytes payload;\\r\\n    }\\r\\n\\r\\n    struct AssetMeta {\\r\\n        uint8 payloadID;\\r\\n        bytes32 tokenAddress;\\r\\n        uint16 tokenChain;\\r\\n        uint8 decimals;\\r\\n        bytes32 symbol;\\r\\n        bytes32 name;\\r\\n    }\\r\\n\\r\\n    struct RegisterChain {\\r\\n        bytes32 module;\\r\\n        uint8 action;\\r\\n        uint16 chainId;\\r\\n\\r\\n        uint16 emitterChainID;\\r\\n        bytes32 emitterAddress;\\r\\n    }\\r\\n\\r\\n     struct UpgradeContract {\\r\\n        bytes32 module;\\r\\n        uint8 action;\\r\\n        uint16 chainId;\\r\\n\\r\\n        bytes32 newContract;\\r\\n    }\\r\\n\\r\\n    struct RecoverChainId {\\r\\n        bytes32 module;\\r\\n        uint8 action;\\r\\n\\r\\n        uint256 evmChainId;\\r\\n        uint16 newChainId;\\r\\n    }\\r\\n\\r\\n    event ContractUpgraded(address indexed oldContract, address indexed newContract);\\r\\n\\r\\n    function _parseTransferCommon(bytes memory encoded) external pure returns (Transfer memory transfer);\\r\\n\\r\\n    function attestToken(address tokenAddress, uint32 nonce) external payable returns (uint64 sequence);\\r\\n\\r\\n    function wrapAndTransferETH(uint16 recipientChain, bytes32 recipient, uint256 arbiterFee, uint32 nonce) external payable returns (uint64 sequence);\\r\\n\\r\\n    function wrapAndTransferETHWithPayload(uint16 recipientChain, bytes32 recipient, uint32 nonce, bytes memory payload) external payable returns (uint64 sequence);\\r\\n\\r\\n    function transferTokens(address token, uint256 amount, uint16 recipientChain, bytes32 recipient, uint256 arbiterFee, uint32 nonce) external payable returns (uint64 sequence);\\r\\n\\r\\n    function transferTokensWithPayload(address token, uint256 amount, uint16 recipientChain, bytes32 recipient, uint32 nonce, bytes memory payload) external payable returns (uint64 sequence);\\r\\n\\r\\n    function updateWrapped(bytes memory encodedVm) external returns (address token);\\r\\n\\r\\n    function createWrapped(bytes memory encodedVm) external returns (address token);\\r\\n\\r\\n    function completeTransferWithPayload(bytes memory encodedVm) external returns (bytes memory);\\r\\n\\r\\n    function completeTransferAndUnwrapETHWithPayload(bytes memory encodedVm) external returns (bytes memory);\\r\\n\\r\\n    function completeTransfer(bytes memory encodedVm) external;\\r\\n\\r\\n    function completeTransferAndUnwrapETH(bytes memory encodedVm) external;\\r\\n\\r\\n    function encodeAssetMeta(AssetMeta memory meta) external pure returns (bytes memory encoded);\\r\\n\\r\\n    function encodeTransfer(Transfer memory transfer) external pure returns (bytes memory encoded);\\r\\n\\r\\n    function encodeTransferWithPayload(TransferWithPayload memory transfer) external pure returns (bytes memory encoded);\\r\\n\\r\\n    function parsePayloadID(bytes memory encoded) external pure returns (uint8 payloadID);\\r\\n\\r\\n    function parseAssetMeta(bytes memory encoded) external pure returns (AssetMeta memory meta);\\r\\n\\r\\n    function parseTransfer(bytes memory encoded) external pure returns (Transfer memory transfer);\\r\\n\\r\\n    function parseTransferWithPayload(bytes memory encoded) external pure returns (TransferWithPayload memory transfer);\\r\\n\\r\\n    function governanceActionIsConsumed(bytes32 hash) external view returns (bool);\\r\\n\\r\\n    function isInitialized(address impl) external view returns (bool);\\r\\n\\r\\n    function isTransferCompleted(bytes32 hash) external view returns (bool);\\r\\n\\r\\n    function wormhole() external view returns (IWormhole);\\r\\n\\r\\n    function chainId() external view returns (uint16);\\r\\n\\r\\n    function evmChainId() external view returns (uint256);\\r\\n\\r\\n    function isFork() external view returns (bool);\\r\\n\\r\\n    function governanceChainId() external view returns (uint16);\\r\\n\\r\\n    function governanceContract() external view returns (bytes32);\\r\\n\\r\\n    function wrappedAsset(uint16 tokenChainId, bytes32 tokenAddress) external view returns (address);\\r\\n\\r\\n    function bridgeContracts(uint16 chainId_) external view returns (bytes32);\\r\\n\\r\\n    function tokenImplementation() external view returns (address);\\r\\n\\r\\n    function WETH() external view returns (IWETH);\\r\\n\\r\\n    function outstandingBridged(address token) external view returns (uint256);\\r\\n\\r\\n    function isWrappedAsset(address token) external view returns (bool);\\r\\n\\r\\n    function finality() external view returns (uint8);\\r\\n\\r\\n    function implementation() external view returns (address);\\r\\n\\r\\n    function initialize() external;\\r\\n\\r\\n    function registerChain(bytes memory encodedVM) external;\\r\\n\\r\\n    function upgrade(bytes memory encodedVM) external;\\r\\n\\r\\n    function submitRecoverChainId(bytes memory encodedVM) external;\\r\\n\\r\\n    function parseRegisterChain(bytes memory encoded) external pure returns (RegisterChain memory chain);\\r\\n\\r\\n    function parseUpgrade(bytes memory encoded) external pure returns (UpgradeContract memory chain);\\r\\n\\r\\n    function parseRecoverChainId(bytes memory encodedRecoverChainId) external pure returns (RecoverChainId memory rci);\\r\\n}\",\"keccak256\":\"0x0d35080aa52e3fd3899515c03bec6a074511c44ba4bc2351bc8f56c762333415\",\"license\":\"Apache 2\"},\"contracts/interfaces/ITokenMinter.sol\":{\"content\":\"// SPDX-License-Identifier: Apache 2\\r\\npragma solidity ^0.8.19;\\r\\n\\r\\n/**\\r\\n * @title ITokenMinter\\r\\n * @notice interface for minter of tokens that are mintable, burnable, and interchangeable\\r\\n * across domains.\\r\\n */\\r\\ninterface ITokenMinter {\\r\\n    function burnLimitsPerMessage(address token) external view returns (uint256);\\r\\n\\r\\n    function remoteTokensToLocalTokens(bytes32 sourceIdHash) external view returns (address);\\r\\n}\",\"keccak256\":\"0x12650fff8a3938b8576858a7586d75867bbcfef47adf1f21183fbc02c2d2aa22\",\"license\":\"Apache 2\"},\"contracts/interfaces/IWETH.sol\":{\"content\":\"// SPDX-License-Identifier: Apache 2\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\ninterface IWETH is IERC20 {\\r\\n    function deposit() external payable;\\r\\n    function withdraw(uint256 amount) external;\\r\\n}\",\"keccak256\":\"0x9b8d44bf877158307b1ae28d42594488c5560d67b81d97a162c3af69d55784d8\",\"license\":\"Apache 2\"},\"contracts/interfaces/IWormhole.sol\":{\"content\":\"// SPDX-License-Identifier: Apache 2\\r\\n\\r\\npragma solidity ^0.8.27;\\r\\n\\r\\ninterface IWormhole {\\r\\n    struct Provider {\\r\\n        uint16 chainId;\\r\\n        uint16 governanceChainId;\\r\\n        bytes32 governanceContract;\\r\\n    }\\r\\n\\r\\n    struct GuardianSet {\\r\\n        address[] keys;\\r\\n        uint32 expirationTime;\\r\\n    }\\r\\n\\r\\n    struct Signature {\\r\\n        bytes32 r;\\r\\n        bytes32 s;\\r\\n        uint8 v;\\r\\n        uint8 guardianIndex;\\r\\n    }\\r\\n\\r\\n    struct VM {\\r\\n        uint8 version;\\r\\n        uint32 timestamp;\\r\\n        uint32 nonce;\\r\\n        uint16 emitterChainId;\\r\\n        bytes32 emitterAddress;\\r\\n        uint64 sequence;\\r\\n        uint8 consistencyLevel;\\r\\n        bytes payload;\\r\\n        uint32 guardianSetIndex;\\r\\n        Signature[] signatures;\\r\\n        bytes32 hash;\\r\\n    }\\r\\n\\r\\n    event LogMessagePublished(address indexed sender, uint64 sequence, uint32 nonce, bytes payload, uint8 consistencyLevel);\\r\\n\\r\\n    function publishMessage(\\r\\n        uint32 nonce,\\r\\n        bytes memory payload,\\r\\n        uint8 consistencyLevel\\r\\n    ) external payable returns (uint64 sequence);\\r\\n\\r\\n    function parseAndVerifyVM(bytes calldata encodedVM) external view returns (VM memory vm, bool valid, string memory reason);\\r\\n\\r\\n    function verifyVM(VM memory vm) external view returns (bool valid, string memory reason);\\r\\n\\r\\n    function verifySignatures(bytes32 hash, Signature[] memory signatures, GuardianSet memory guardianSet) external pure returns (bool valid, string memory reason) ;\\r\\n\\r\\n    function parseVM(bytes memory encodedVM) external pure returns (VM memory vm);\\r\\n\\r\\n    function getGuardianSet(uint32 index) external view returns (GuardianSet memory) ;\\r\\n\\r\\n    function getCurrentGuardianSetIndex() external view returns (uint32) ;\\r\\n\\r\\n    function getGuardianSetExpiry() external view returns (uint32) ;\\r\\n\\r\\n    function governanceActionIsConsumed(bytes32 hash) external view returns (bool) ;\\r\\n\\r\\n    function isInitialized(address impl) external view returns (bool) ;\\r\\n\\r\\n    function chainId() external view returns (uint16) ;\\r\\n\\r\\n    function governanceChainId() external view returns (uint16);\\r\\n\\r\\n    function governanceContract() external view returns (bytes32);\\r\\n\\r\\n    function messageFee() external view returns (uint256) ;\\r\\n}\",\"keccak256\":\"0xa8ade6b238afb62c778e35cfc1b1448a3ae83c471e94c27945e8164388818bed\",\"license\":\"Apache 2\"},\"contracts/interfaces/IWormholeReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: Apache 2\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @notice Interface for a contract which can receive Wormhole messages.\\r\\n */\\r\\ninterface IWormholeReceiver {\\r\\n  /**\\r\\n   * @notice When a `send` is performed with this contract as the target, this function will be\\r\\n   *     invoked by the WormholeRelayer contract\\r\\n   *\\r\\n   * NOTE: This function should be restricted such that only the Wormhole Relayer contract can call it.\\r\\n   *\\r\\n   * We also recommend that this function checks that `sourceChain` and `sourceAddress` are indeed who\\r\\n   *       you expect to have requested the calling of `send` on the source chain\\r\\n   *\\r\\n   * The invocation of this function corresponding to the `send` request will have msg.value equal\\r\\n   *   to the receiverValue specified in the send request.\\r\\n   *\\r\\n   * If the invocation of this function reverts or exceeds the gas limit\\r\\n   *   specified by the send requester, this delivery will result in a `ReceiverFailure`.\\r\\n   *\\r\\n   * @param payload - an arbitrary message which was included in the delivery by the\\r\\n   *     requester. This message's signature will already have been verified (as long as msg.sender is the Wormhole Relayer contract)\\r\\n   * @param additionalMessages - Additional messages which were requested to be included in this delivery.\\r\\n   *      Note: There are no contract-level guarantees that the messages in this array are what was requested\\r\\n   *      so **you should verify any sensitive information given here!**\\r\\n   *\\r\\n   *      For example, if a 'VaaKey' was specified on the source chain, then MAKE SURE the corresponding message here\\r\\n   *      has valid signatures (by calling `parseAndVerifyVM(message)` on the Wormhole core contract)\\r\\n   *\\r\\n   *      This field can be used to perform and relay TokenBridge or CCTP transfers, and there are example\\r\\n   *      usages of this at\\r\\n   *         https://github.com/wormhole-foundation/hello-token\\r\\n   *         https://github.com/wormhole-foundation/hello-cctp\\r\\n   *\\r\\n   * @param sourceAddress - the (wormhole format) address on the sending chain which requested\\r\\n   *     this delivery.\\r\\n   * @param sourceChain - the wormhole chain ID where this delivery was requested.\\r\\n   * @param deliveryHash - the VAA hash of the deliveryVAA.\\r\\n   *\\r\\n   */\\r\\n  function receiveWormholeMessages(\\r\\n    bytes memory payload,\\r\\n    bytes[] memory additionalMessages,\\r\\n    bytes32 sourceAddress,\\r\\n    uint16 sourceChain,\\r\\n    bytes32 deliveryHash\\r\\n  ) external payable;\\r\\n}\",\"keccak256\":\"0x4a1b272426f2ba189870af46be655e45caebef91de1ac85cdf1bc93937de2c91\",\"license\":\"Apache 2\"},\"contracts/interfaces/IWormholeRelayer.sol\":{\"content\":\"// SPDX-License-Identifier: Apache 2\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @title WormholeRelayer\\r\\n * @author\\r\\n * @notice This project allows developers to build cross-chain applications powered by Wormhole without needing to\\r\\n * write and run their own relaying infrastructure\\r\\n *\\r\\n * We implement the IWormholeRelayer interface that allows users to request a delivery provider to relay a payload (and/or additional messages)\\r\\n * to a chain and address of their choice.\\r\\n */\\r\\n\\r\\n/**\\r\\n * @notice VaaKey identifies a wormhole message\\r\\n *\\r\\n * @custom:member chainId Wormhole chain ID of the chain where this VAA was emitted from\\r\\n * @custom:member emitterAddress Address of the emitter of the VAA, in Wormhole bytes32 format\\r\\n * @custom:member sequence Sequence number of the VAA\\r\\n */\\r\\nstruct VaaKey {\\r\\n  uint16 chainId;\\r\\n  bytes32 emitterAddress;\\r\\n  uint64 sequence;\\r\\n}\\r\\n\\r\\n// 0-127 are reserved for standardized KeyTypes, 128-255 are for custom use\\r\\nuint8 constant VAA_KEY_TYPE = 1;\\r\\n\\r\\nstruct MessageKey {\\r\\n  uint8 keyType; // 0-127 are reserved for standardized KeyTypes, 128-255 are for custom use\\r\\n  bytes encodedKey;\\r\\n}\\r\\n\\r\\ninterface IWormholeRelayerBase {\\r\\n  event SendEvent(\\r\\n    uint64 indexed sequence,\\r\\n    uint256 deliveryQuote,\\r\\n    uint256 paymentForExtraReceiverValue\\r\\n  );\\r\\n\\r\\n  function getRegisteredWormholeRelayerContract(\\r\\n    uint16 chainId\\r\\n  ) external view returns (bytes32);\\r\\n\\r\\n  /**\\r\\n   * @notice Returns true if a delivery has been attempted for the given deliveryHash\\r\\n   * Note: invalid deliveries where the tx reverts are not considered attempted\\r\\n   */\\r\\n  function deliveryAttempted(\\r\\n    bytes32 deliveryHash\\r\\n  ) external view returns (bool attempted);\\r\\n\\r\\n  /**\\r\\n   * @notice block number at which a delivery was successfully executed\\r\\n   */\\r\\n  function deliverySuccessBlock(\\r\\n    bytes32 deliveryHash\\r\\n  ) external view returns (uint256 blockNumber);\\r\\n\\r\\n  /**\\r\\n   * @notice block number of the latest attempt to execute a delivery that failed\\r\\n   */\\r\\n  function deliveryFailureBlock(\\r\\n    bytes32 deliveryHash\\r\\n  ) external view returns (uint256 blockNumber);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title IWormholeRelayerSend\\r\\n * @notice The interface to request deliveries\\r\\n */\\r\\ninterface IWormholeRelayerSend is IWormholeRelayerBase {\\r\\n  /**\\r\\n   * @notice Publishes an instruction for the default delivery provider\\r\\n   * to relay a payload to the address `targetAddress` on chain `targetChain`\\r\\n   * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\\r\\n   *\\r\\n   * `targetAddress` must implement the IWormholeReceiver interface\\r\\n   *\\r\\n   * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\\r\\n   *\\r\\n   * Any refunds (from leftover gas) will be paid to the delivery provider. In order to receive the refunds, use the `sendPayloadToEvm` function\\r\\n   * with `refundChain` and `refundAddress` as parameters\\r\\n   *\\r\\n   * @param targetChain in Wormhole Chain ID format\\r\\n   * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\\r\\n   * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\r\\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\r\\n   * @param gasLimit gas limit with which to call `targetAddress`.\\r\\n   * @return sequence sequence number of published VAA containing delivery instructions\\r\\n   */\\r\\n  function sendPayloadToEvm(\\r\\n    uint16 targetChain,\\r\\n    address targetAddress,\\r\\n    bytes memory payload,\\r\\n    uint256 receiverValue,\\r\\n    uint256 gasLimit\\r\\n  ) external payable returns (uint64 sequence);\\r\\n\\r\\n  /**\\r\\n   * @notice Publishes an instruction for the default delivery provider\\r\\n   * to relay a payload to the address `targetAddress` on chain `targetChain`\\r\\n   * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\\r\\n   *\\r\\n   * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\r\\n   * `targetAddress` must implement the IWormholeReceiver interface\\r\\n   *\\r\\n   * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\\r\\n   *\\r\\n   * @param targetChain in Wormhole Chain ID format\\r\\n   * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\\r\\n   * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\r\\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\r\\n   * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\\r\\n   *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\\r\\n   * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\r\\n   * @param refundAddress The address on `refundChain` to deliver any refund to\\r\\n   * @return sequence sequence number of published VAA containing delivery instructions\\r\\n   */\\r\\n  function sendPayloadToEvm(\\r\\n    uint16 targetChain,\\r\\n    address targetAddress,\\r\\n    bytes memory payload,\\r\\n    uint256 receiverValue,\\r\\n    uint256 gasLimit,\\r\\n    uint16 refundChain,\\r\\n    address refundAddress\\r\\n  ) external payable returns (uint64 sequence);\\r\\n\\r\\n  /**\\r\\n   * @notice Publishes an instruction for the default delivery provider\\r\\n   * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\\r\\n   * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\\r\\n   *\\r\\n   * `targetAddress` must implement the IWormholeReceiver interface\\r\\n   *\\r\\n   * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\\r\\n   *\\r\\n   * Any refunds (from leftover gas) will be paid to the delivery provider. In order to receive the refunds, use the `sendVaasToEvm` function\\r\\n   * with `refundChain` and `refundAddress` as parameters\\r\\n   *\\r\\n   * @param targetChain in Wormhole Chain ID format\\r\\n   * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\\r\\n   * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\r\\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\r\\n   * @param gasLimit gas limit with which to call `targetAddress`.\\r\\n   * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\\r\\n   * @return sequence sequence number of published VAA containing delivery instructions\\r\\n   */\\r\\n  function sendVaasToEvm(\\r\\n    uint16 targetChain,\\r\\n    address targetAddress,\\r\\n    bytes memory payload,\\r\\n    uint256 receiverValue,\\r\\n    uint256 gasLimit,\\r\\n    VaaKey[] memory vaaKeys\\r\\n  ) external payable returns (uint64 sequence);\\r\\n\\r\\n  /**\\r\\n   * @notice Publishes an instruction for the default delivery provider\\r\\n   * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\\r\\n   * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\\r\\n   *\\r\\n   * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\r\\n   * `targetAddress` must implement the IWormholeReceiver interface\\r\\n   *\\r\\n   * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\\r\\n   *\\r\\n   * @param targetChain in Wormhole Chain ID format\\r\\n   * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\\r\\n   * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\r\\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\r\\n   * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\\r\\n   *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\\r\\n   * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\\r\\n   * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\r\\n   * @param refundAddress The address on `refundChain` to deliver any refund to\\r\\n   * @return sequence sequence number of published VAA containing delivery instructions\\r\\n   */\\r\\n  function sendVaasToEvm(\\r\\n    uint16 targetChain,\\r\\n    address targetAddress,\\r\\n    bytes memory payload,\\r\\n    uint256 receiverValue,\\r\\n    uint256 gasLimit,\\r\\n    VaaKey[] memory vaaKeys,\\r\\n    uint16 refundChain,\\r\\n    address refundAddress\\r\\n  ) external payable returns (uint64 sequence);\\r\\n\\r\\n  /**\\r\\n   * @notice Publishes an instruction for the delivery provider at `deliveryProviderAddress`\\r\\n   * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\\r\\n   * with gas limit `gasLimit` and `msg.value` equal to\\r\\n   * receiverValue + (arbitrary amount that is paid for by paymentForExtraReceiverValue of this chain's wei) in targetChain wei.\\r\\n   *\\r\\n   * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\r\\n   * `targetAddress` must implement the IWormholeReceiver interface\\r\\n   *\\r\\n   * This function must be called with `msg.value` equal to\\r\\n   * quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit, deliveryProviderAddress) + paymentForExtraReceiverValue\\r\\n   *\\r\\n   * @param targetChain in Wormhole Chain ID format\\r\\n   * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\\r\\n   * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\r\\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\r\\n   * @param paymentForExtraReceiverValue amount (in current chain currency units) to spend on extra receiverValue\\r\\n   *        (in addition to the `receiverValue` specified)\\r\\n   * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\\r\\n   *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\\r\\n   * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\r\\n   * @param refundAddress The address on `refundChain` to deliver any refund to\\r\\n   * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\r\\n   * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\\r\\n   * @param consistencyLevel Consistency level with which to publish the delivery instructions - see\\r\\n   *        https://book.wormhole.com/wormhole/3_coreLayerContracts.html?highlight=consistency#consistency-levels\\r\\n   * @return sequence sequence number of published VAA containing delivery instructions\\r\\n   */\\r\\n  function sendToEvm(\\r\\n    uint16 targetChain,\\r\\n    address targetAddress,\\r\\n    bytes memory payload,\\r\\n    uint256 receiverValue,\\r\\n    uint256 paymentForExtraReceiverValue,\\r\\n    uint256 gasLimit,\\r\\n    uint16 refundChain,\\r\\n    address refundAddress,\\r\\n    address deliveryProviderAddress,\\r\\n    VaaKey[] memory vaaKeys,\\r\\n    uint8 consistencyLevel\\r\\n  ) external payable returns (uint64 sequence);\\r\\n\\r\\n  /**\\r\\n   * @notice Publishes an instruction for the delivery provider at `deliveryProviderAddress`\\r\\n   * to relay a payload and external messages specified by `messageKeys` to the address `targetAddress` on chain `targetChain`\\r\\n   * with gas limit `gasLimit` and `msg.value` equal to\\r\\n   * receiverValue + (arbitrary amount that is paid for by paymentForExtraReceiverValue of this chain's wei) in targetChain wei.\\r\\n   *\\r\\n   * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\r\\n   * `targetAddress` must implement the IWormholeReceiver interface\\r\\n   *\\r\\n   * This function must be called with `msg.value` equal to\\r\\n   * quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit, deliveryProviderAddress) + paymentForExtraReceiverValue\\r\\n   *\\r\\n   * Note: MessageKeys can specify wormhole messages (VaaKeys) or other types of messages (ex. USDC CCTP attestations). Ensure the selected\\r\\n   * DeliveryProvider supports all the MessageKey.keyType values specified or it will not be delivered!\\r\\n   *\\r\\n   * @param targetChain in Wormhole Chain ID format\\r\\n   * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\\r\\n   * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\r\\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\r\\n   * @param paymentForExtraReceiverValue amount (in current chain currency units) to spend on extra receiverValue\\r\\n   *        (in addition to the `receiverValue` specified)\\r\\n   * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\\r\\n   *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\\r\\n   * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\r\\n   * @param refundAddress The address on `refundChain` to deliver any refund to\\r\\n   * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\r\\n   * @param messageKeys Additional messagess to pass in as parameter in call to `targetAddress`\\r\\n   * @param consistencyLevel Consistency level with which to publish the delivery instructions - see\\r\\n   *        https://book.wormhole.com/wormhole/3_coreLayerContracts.html?highlight=consistency#consistency-levels\\r\\n   * @return sequence sequence number of published VAA containing delivery instructions\\r\\n   */\\r\\n  function sendToEvm(\\r\\n    uint16 targetChain,\\r\\n    address targetAddress,\\r\\n    bytes memory payload,\\r\\n    uint256 receiverValue,\\r\\n    uint256 paymentForExtraReceiverValue,\\r\\n    uint256 gasLimit,\\r\\n    uint16 refundChain,\\r\\n    address refundAddress,\\r\\n    address deliveryProviderAddress,\\r\\n    MessageKey[] memory messageKeys,\\r\\n    uint8 consistencyLevel\\r\\n  ) external payable returns (uint64 sequence);\\r\\n\\r\\n  /**\\r\\n   * @notice Publishes an instruction for the delivery provider at `deliveryProviderAddress`\\r\\n   * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\\r\\n   * with `msg.value` equal to\\r\\n   * receiverValue + (arbitrary amount that is paid for by paymentForExtraReceiverValue of this chain's wei) in targetChain wei.\\r\\n   *\\r\\n   * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\r\\n   * `targetAddress` must implement the IWormholeReceiver interface\\r\\n   *\\r\\n   * This function must be called with `msg.value` equal to\\r\\n   * quoteDeliveryPrice(targetChain, receiverValue, encodedExecutionParameters, deliveryProviderAddress) + paymentForExtraReceiverValue\\r\\n   *\\r\\n   * @param targetChain in Wormhole Chain ID format\\r\\n   * @param targetAddress address to call on targetChain (that implements IWormholeReceiver), in Wormhole bytes32 format\\r\\n   * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\r\\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\r\\n   * @param paymentForExtraReceiverValue amount (in current chain currency units) to spend on extra receiverValue\\r\\n   *        (in addition to the `receiverValue` specified)\\r\\n   * @param encodedExecutionParameters encoded information on how to execute delivery that may impact pricing\\r\\n   *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\\r\\n   * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\r\\n   * @param refundAddress The address on `refundChain` to deliver any refund to, in Wormhole bytes32 format\\r\\n   * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\r\\n   * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\\r\\n   * @param consistencyLevel Consistency level with which to publish the delivery instructions - see\\r\\n   *        https://book.wormhole.com/wormhole/3_coreLayerContracts.html?highlight=consistency#consistency-levels\\r\\n   * @return sequence sequence number of published VAA containing delivery instructions\\r\\n   */\\r\\n  function send(\\r\\n    uint16 targetChain,\\r\\n    bytes32 targetAddress,\\r\\n    bytes memory payload,\\r\\n    uint256 receiverValue,\\r\\n    uint256 paymentForExtraReceiverValue,\\r\\n    bytes memory encodedExecutionParameters,\\r\\n    uint16 refundChain,\\r\\n    bytes32 refundAddress,\\r\\n    address deliveryProviderAddress,\\r\\n    VaaKey[] memory vaaKeys,\\r\\n    uint8 consistencyLevel\\r\\n  ) external payable returns (uint64 sequence);\\r\\n\\r\\n  /**\\r\\n   * @notice Publishes an instruction for the delivery provider at `deliveryProviderAddress`\\r\\n   * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\\r\\n   * with `msg.value` equal to\\r\\n   * receiverValue + (arbitrary amount that is paid for by paymentForExtraReceiverValue of this chain's wei) in targetChain wei.\\r\\n   *\\r\\n   * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\r\\n   * `targetAddress` must implement the IWormholeReceiver interface\\r\\n   *\\r\\n   * This function must be called with `msg.value` equal to\\r\\n   * quoteDeliveryPrice(targetChain, receiverValue, encodedExecutionParameters, deliveryProviderAddress) + paymentForExtraReceiverValue\\r\\n   *\\r\\n   * Note: MessageKeys can specify wormhole messages (VaaKeys) or other types of messages (ex. USDC CCTP attestations). Ensure the selected\\r\\n   * DeliveryProvider supports all the MessageKey.keyType values specified or it will not be delivered!\\r\\n   *\\r\\n   * @param targetChain in Wormhole Chain ID format\\r\\n   * @param targetAddress address to call on targetChain (that implements IWormholeReceiver), in Wormhole bytes32 format\\r\\n   * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\r\\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\r\\n   * @param paymentForExtraReceiverValue amount (in current chain currency units) to spend on extra receiverValue\\r\\n   *        (in addition to the `receiverValue` specified)\\r\\n   * @param encodedExecutionParameters encoded information on how to execute delivery that may impact pricing\\r\\n   *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\\r\\n   * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\r\\n   * @param refundAddress The address on `refundChain` to deliver any refund to, in Wormhole bytes32 format\\r\\n   * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\r\\n   * @param messageKeys Additional messagess to pass in as parameter in call to `targetAddress`\\r\\n   * @param consistencyLevel Consistency level with which to publish the delivery instructions - see\\r\\n   *        https://book.wormhole.com/wormhole/3_coreLayerContracts.html?highlight=consistency#consistency-levels\\r\\n   * @return sequence sequence number of published VAA containing delivery instructions\\r\\n   */\\r\\n  function send(\\r\\n    uint16 targetChain,\\r\\n    bytes32 targetAddress,\\r\\n    bytes memory payload,\\r\\n    uint256 receiverValue,\\r\\n    uint256 paymentForExtraReceiverValue,\\r\\n    bytes memory encodedExecutionParameters,\\r\\n    uint16 refundChain,\\r\\n    bytes32 refundAddress,\\r\\n    address deliveryProviderAddress,\\r\\n    MessageKey[] memory messageKeys,\\r\\n    uint8 consistencyLevel\\r\\n  ) external payable returns (uint64 sequence);\\r\\n\\r\\n  /**\\r\\n   * @notice Requests a previously published delivery instruction to be redelivered\\r\\n   * (e.g. with a different delivery provider)\\r\\n   *\\r\\n   * This function must be called with `msg.value` equal to\\r\\n   * quoteEVMDeliveryPrice(targetChain, newReceiverValue, newGasLimit, newDeliveryProviderAddress)\\r\\n   *\\r\\n   *  @notice *** This will only be able to succeed if the following is true **\\r\\n   *         - newGasLimit >= gas limit of the old instruction\\r\\n   *         - newReceiverValue >= receiver value of the old instruction\\r\\n   *         - newDeliveryProvider's `targetChainRefundPerGasUnused` >= old relay provider's `targetChainRefundPerGasUnused`\\r\\n   *\\r\\n   * @param deliveryVaaKey VaaKey identifying the wormhole message containing the\\r\\n   *        previously published delivery instructions\\r\\n   * @param targetChain The target chain that the original delivery targeted. Must match targetChain from original delivery instructions\\r\\n   * @param newReceiverValue new msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\r\\n   * @param newGasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\\r\\n   *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider, to the refund chain and address specified in the original request\\r\\n   * @param newDeliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\r\\n   * @return sequence sequence number of published VAA containing redelivery instructions\\r\\n   *\\r\\n   * @notice *** This will only be able to succeed if the following is true **\\r\\n   *         - newGasLimit >= gas limit of the old instruction\\r\\n   *         - newReceiverValue >= receiver value of the old instruction\\r\\n   */\\r\\n  function resendToEvm(\\r\\n    VaaKey memory deliveryVaaKey,\\r\\n    uint16 targetChain,\\r\\n    uint256 newReceiverValue,\\r\\n    uint256 newGasLimit,\\r\\n    address newDeliveryProviderAddress\\r\\n  ) external payable returns (uint64 sequence);\\r\\n\\r\\n  /**\\r\\n   * @notice Requests a previously published delivery instruction to be redelivered\\r\\n   *\\r\\n   *\\r\\n   * This function must be called with `msg.value` equal to\\r\\n   * quoteDeliveryPrice(targetChain, newReceiverValue, newEncodedExecutionParameters, newDeliveryProviderAddress)\\r\\n   *\\r\\n   * @param deliveryVaaKey VaaKey identifying the wormhole message containing the\\r\\n   *        previously published delivery instructions\\r\\n   * @param targetChain The target chain that the original delivery targeted. Must match targetChain from original delivery instructions\\r\\n   * @param newReceiverValue new msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\r\\n   * @param newEncodedExecutionParameters new encoded information on how to execute delivery that may impact pricing\\r\\n   *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\\r\\n   * @param newDeliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\r\\n   * @return sequence sequence number of published VAA containing redelivery instructions\\r\\n   *\\r\\n   *  @notice *** This will only be able to succeed if the following is true **\\r\\n   *         - (For EVM_V1) newGasLimit >= gas limit of the old instruction\\r\\n   *         - newReceiverValue >= receiver value of the old instruction\\r\\n   *         - (For EVM_V1) newDeliveryProvider's `targetChainRefundPerGasUnused` >= old relay provider's `targetChainRefundPerGasUnused`\\r\\n   */\\r\\n  function resend(\\r\\n    VaaKey memory deliveryVaaKey,\\r\\n    uint16 targetChain,\\r\\n    uint256 newReceiverValue,\\r\\n    bytes memory newEncodedExecutionParameters,\\r\\n    address newDeliveryProviderAddress\\r\\n  ) external payable returns (uint64 sequence);\\r\\n\\r\\n  /**\\r\\n   * @notice Returns the price to request a relay to chain `targetChain`, using the default delivery provider\\r\\n   *\\r\\n   * @param targetChain in Wormhole Chain ID format\\r\\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\r\\n   * @param gasLimit gas limit with which to call `targetAddress`.\\r\\n   * @return nativePriceQuote Price, in units of current chain currency, that the delivery provider charges to perform the relay\\r\\n   * @return targetChainRefundPerGasUnused amount of target chain currency that will be refunded per unit of gas unused,\\r\\n   *         if a refundAddress is specified.\\r\\n   *         Note: This value can be overridden by the delivery provider on the target chain. The returned value here should be considered to be a\\r\\n   *         promise by the delivery provider of the amount of refund per gas unused that will be returned to the refundAddress at the target chain.\\r\\n   *         If a delivery provider decides to override, this will be visible as part of the emitted Delivery event on the target chain.\\r\\n   */\\r\\n  function quoteEVMDeliveryPrice(\\r\\n    uint16 targetChain,\\r\\n    uint256 receiverValue,\\r\\n    uint256 gasLimit\\r\\n  )\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n        uint256 nativePriceQuote,\\r\\n        uint256 targetChainRefundPerGasUnused\\r\\n    );\\r\\n\\r\\n  /**\\r\\n   * @notice Returns the price to request a relay to chain `targetChain`, using delivery provider `deliveryProviderAddress`\\r\\n   *\\r\\n   * @param targetChain in Wormhole Chain ID format\\r\\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\r\\n   * @param gasLimit gas limit with which to call `targetAddress`.\\r\\n   * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\r\\n   * @return nativePriceQuote Price, in units of current chain currency, that the delivery provider charges to perform the relay\\r\\n   * @return targetChainRefundPerGasUnused amount of target chain currency that will be refunded per unit of gas unused,\\r\\n   *         if a refundAddress is specified\\r\\n   *         Note: This value can be overridden by the delivery provider on the target chain. The returned value here should be considered to be a\\r\\n   *         promise by the delivery provider of the amount of refund per gas unused that will be returned to the refundAddress at the target chain.\\r\\n   *         If a delivery provider decides to override, this will be visible as part of the emitted Delivery event on the target chain.\\r\\n   */\\r\\n  function quoteEVMDeliveryPrice(\\r\\n    uint16 targetChain,\\r\\n    uint256 receiverValue,\\r\\n    uint256 gasLimit,\\r\\n    address deliveryProviderAddress\\r\\n  )\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n        uint256 nativePriceQuote,\\r\\n        uint256 targetChainRefundPerGasUnused\\r\\n    );\\r\\n\\r\\n  /**\\r\\n   * @notice Returns the price to request a relay to chain `targetChain`, using delivery provider `deliveryProviderAddress`\\r\\n   *\\r\\n   * @param targetChain in Wormhole Chain ID format\\r\\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\r\\n   * @param encodedExecutionParameters encoded information on how to execute delivery that may impact pricing\\r\\n   *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\\r\\n   * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\r\\n   * @return nativePriceQuote Price, in units of current chain currency, that the delivery provider charges to perform the relay\\r\\n   * @return encodedExecutionInfo encoded information on how the delivery will be executed\\r\\n   *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` and `targetChainRefundPerGasUnused`\\r\\n   *             (which is the amount of target chain currency that will be refunded per unit of gas unused,\\r\\n   *              if a refundAddress is specified)\\r\\n   */\\r\\n  function quoteDeliveryPrice(\\r\\n    uint16 targetChain,\\r\\n    uint256 receiverValue,\\r\\n    bytes memory encodedExecutionParameters,\\r\\n    address deliveryProviderAddress\\r\\n  )\\r\\n    external\\r\\n    view\\r\\n    returns (uint256 nativePriceQuote, bytes memory encodedExecutionInfo);\\r\\n\\r\\n  /**\\r\\n   * @notice Returns the (extra) amount of target chain currency that `targetAddress`\\r\\n   * will be called with, if the `paymentForExtraReceiverValue` field is set to `currentChainAmount`\\r\\n   *\\r\\n   * @param targetChain in Wormhole Chain ID format\\r\\n   * @param currentChainAmount The value that `paymentForExtraReceiverValue` will be set to\\r\\n   * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\r\\n   * @return targetChainAmount The amount such that if `targetAddress` will be called with `msg.value` equal to\\r\\n   *         receiverValue + targetChainAmount\\r\\n   */\\r\\n  function quoteNativeForChain(\\r\\n    uint16 targetChain,\\r\\n    uint256 currentChainAmount,\\r\\n    address deliveryProviderAddress\\r\\n  ) external view returns (uint256 targetChainAmount);\\r\\n\\r\\n  /**\\r\\n   * @notice Returns the address of the current default delivery provider\\r\\n   * @return deliveryProvider The address of (the default delivery provider)'s contract on this source\\r\\n   *   chain. This must be a contract that implements IDeliveryProvider.\\r\\n   */\\r\\n  function getDefaultDeliveryProvider()\\r\\n    external\\r\\n    view\\r\\n    returns (address deliveryProvider);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title IWormholeRelayerDelivery\\r\\n * @notice The interface to execute deliveries. Only relevant for Delivery Providers\\r\\n */\\r\\ninterface IWormholeRelayerDelivery is IWormholeRelayerBase {\\r\\n  enum DeliveryStatus {\\r\\n    SUCCESS,\\r\\n    RECEIVER_FAILURE\\r\\n  }\\r\\n\\r\\n  enum RefundStatus {\\r\\n    REFUND_SENT,\\r\\n    REFUND_FAIL,\\r\\n    CROSS_CHAIN_REFUND_SENT,\\r\\n    CROSS_CHAIN_REFUND_FAIL_PROVIDER_NOT_SUPPORTED,\\r\\n    CROSS_CHAIN_REFUND_FAIL_NOT_ENOUGH,\\r\\n    NO_REFUND_REQUESTED\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @custom:member recipientContract - The target contract address\\r\\n   * @custom:member sourceChain - The chain which this delivery was requested from (in wormhole\\r\\n   *     ChainID format)\\r\\n   * @custom:member sequence - The wormhole sequence number of the delivery VAA on the source chain\\r\\n   *     corresponding to this delivery request\\r\\n   * @custom:member deliveryVaaHash - The hash of the delivery VAA corresponding to this delivery\\r\\n   *     request\\r\\n   * @custom:member gasUsed - The amount of gas that was used to call your target contract\\r\\n   * @custom:member status:\\r\\n   *   - RECEIVER_FAILURE, if the target contract reverts\\r\\n   *   - SUCCESS, if the target contract doesn't revert\\r\\n   * @custom:member additionalStatusInfo:\\r\\n   *   - If status is SUCCESS, then this is empty.\\r\\n   *   - If status is RECEIVER_FAILURE, this is `RETURNDATA_TRUNCATION_THRESHOLD` bytes of the\\r\\n   *       return data (i.e. potentially truncated revert reason information).\\r\\n   * @custom:member refundStatus - Result of the refund. REFUND_SUCCESS or REFUND_FAIL are for\\r\\n   *     refunds where targetChain=refundChain; the others are for targetChain!=refundChain,\\r\\n   *     where a cross chain refund is necessary, or if the default code path is used where no refund is requested (NO_REFUND_REQUESTED)\\r\\n   * @custom:member overridesInfo:\\r\\n   *   - If not an override: empty bytes array\\r\\n   *   - Otherwise: An encoded `DeliveryOverride`\\r\\n   */\\r\\n  event Delivery(\\r\\n    address indexed recipientContract,\\r\\n    uint16 indexed sourceChain,\\r\\n    uint64 indexed sequence,\\r\\n    bytes32 deliveryVaaHash,\\r\\n    DeliveryStatus status,\\r\\n    uint256 gasUsed,\\r\\n    RefundStatus refundStatus,\\r\\n    bytes additionalStatusInfo,\\r\\n    bytes overridesInfo\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @notice The delivery provider calls `deliver` to relay messages as described by one delivery instruction\\r\\n   *\\r\\n   * The delivery provider must pass in the specified (by VaaKeys[]) signed wormhole messages (VAAs) from the source chain\\r\\n   * as well as the signed wormhole message with the delivery instructions (the delivery VAA)\\r\\n   *\\r\\n   * The messages will be relayed to the target address (with the specified gas limit and receiver value) iff the following checks are met:\\r\\n   * - the delivery VAA has a valid signature\\r\\n   * - the delivery VAA's emitter is one of these WormholeRelayer contracts\\r\\n   * - the delivery provider passed in at least enough of this chain's currency as msg.value (enough meaning the maximum possible refund)\\r\\n   * - the instruction's target chain is this chain\\r\\n   * - the relayed signed VAAs match the descriptions in container.messages (the VAA hashes match, or the emitter address, sequence number pair matches, depending on the description given)\\r\\n   *\\r\\n   * @param encodedVMs - An array of signed wormhole messages (all from the same source chain\\r\\n   *     transaction)\\r\\n   * @param encodedDeliveryVAA - Signed wormhole message from the source chain's WormholeRelayer\\r\\n   *     contract with payload being the encoded delivery instruction container\\r\\n   * @param relayerRefundAddress - The address to which any refunds to the delivery provider\\r\\n   *     should be sent\\r\\n   * @param deliveryOverrides - Optional overrides field which must be either an empty bytes array or\\r\\n   *     an encoded DeliveryOverride struct\\r\\n   */\\r\\n  function deliver(\\r\\n    bytes[] memory encodedVMs,\\r\\n    bytes memory encodedDeliveryVAA,\\r\\n    address payable relayerRefundAddress,\\r\\n    bytes memory deliveryOverrides\\r\\n  ) external payable;\\r\\n}\\r\\n\\r\\ninterface IWormholeRelayer is IWormholeRelayerDelivery, IWormholeRelayerSend {}\\r\\n\\r\\n/*\\r\\n *  Errors thrown by IWormholeRelayer contract\\r\\n */\\r\\n\\r\\n// Bound chosen by the following formula: `memoryWord * 4 + selectorSize`.\\r\\n// This means that an error identifier plus four fixed size arguments should be available to developers.\\r\\n// In the case of a `require` revert with error message, this should provide 2 memory word's worth of data.\\r\\nuint256 constant RETURNDATA_TRUNCATION_THRESHOLD = 132;\\r\\n\\r\\n//When msg.value was not equal to `delivery provider's quoted delivery price` + `paymentForExtraReceiverValue`\\r\\nerror InvalidMsgValue(uint256 msgValue, uint256 totalFee);\\r\\n\\r\\nerror RequestedGasLimitTooLow();\\r\\n\\r\\nerror DeliveryProviderDoesNotSupportTargetChain(\\r\\n  address relayer,\\r\\n  uint16 chainId\\r\\n);\\r\\nerror DeliveryProviderCannotReceivePayment();\\r\\nerror DeliveryProviderDoesNotSupportMessageKeyType(uint8 keyType);\\r\\n\\r\\n//When calling `delivery()` a second time even though a delivery is already in progress\\r\\nerror ReentrantDelivery(address msgSender, address lockedBy);\\r\\n\\r\\nerror InvalidPayloadId(uint8 parsed, uint8 expected);\\r\\nerror InvalidPayloadLength(uint256 received, uint256 expected);\\r\\nerror InvalidVaaKeyType(uint8 parsed);\\r\\nerror TooManyMessageKeys(uint256 numMessageKeys);\\r\\n\\r\\nerror InvalidDeliveryVaa(string reason);\\r\\n//When the delivery VAA (signed wormhole message with delivery instructions) was not emitted by the\\r\\n//  registered WormholeRelayer contract\\r\\nerror InvalidEmitter(bytes32 emitter, bytes32 registered, uint16 chainId);\\r\\nerror MessageKeysLengthDoesNotMatchMessagesLength(uint256 keys, uint256 vaas);\\r\\nerror VaaKeysDoNotMatchVaas(uint8 index);\\r\\n//When someone tries to call an external function of the WormholeRelayer that is only intended to be\\r\\n//  called by the WormholeRelayer itself (to allow retroactive reverts for atomicity)\\r\\nerror RequesterNotWormholeRelayer();\\r\\n\\r\\n//When trying to relay a `DeliveryInstruction` to any other chain but the one it was specified for\\r\\nerror TargetChainIsNotThisChain(uint16 targetChain);\\r\\n//When a `DeliveryOverride` contains a gas limit that's less than the original\\r\\nerror InvalidOverrideGasLimit();\\r\\n//When a `DeliveryOverride` contains a receiver value that's less than the original\\r\\nerror InvalidOverrideReceiverValue();\\r\\n//When a `DeliveryOverride` contains a 'refund per unit of gas unused' that's less than the original\\r\\nerror InvalidOverrideRefundPerGasUnused();\\r\\n\\r\\n//When the delivery provider doesn't pass in sufficient funds (i.e. msg.value does not cover the\\r\\n// maximum possible refund to the user)\\r\\nerror InsufficientRelayerFunds(uint256 msgValue, uint256 minimum);\\r\\n\\r\\n//When a bytes32 field can't be converted into a 20 byte EVM address, because the 12 padding bytes\\r\\n//  are non-zero (see Utils.sol)\\r\\n//error NotAnEvmAddress(bytes32);\",\"keccak256\":\"0x63fd89d237b17fa4b73dfc593d3c9c5d29c21504150fa98904fa7d60f38a7404\",\"license\":\"Apache 2\"},\"contracts/libraries/BytesLib.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\r\\n/*\\r\\n * @title Solidity Bytes Arrays Utils\\r\\n * @author Gon\\u00e7alo S\\u00e1 <goncalo.sa@consensys.net>\\r\\n *\\r\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\r\\n *      This is a reduced version of the library.\\r\\n */\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nlibrary BytesLib {\\r\\n    uint256 private constant freeMemoryPtr = 0x40;\\r\\n    uint256 private constant maskModulo32 = 0x1f;\\r\\n    /**\\r\\n     * Size of word read by `mload` instruction.\\r\\n     */\\r\\n    uint256 private constant memoryWord = 32;\\r\\n    uint256 internal constant uint8Size = 1;\\r\\n    uint256 internal constant uint16Size = 2;\\r\\n    uint256 internal constant uint32Size = 4;\\r\\n    uint256 internal constant uint64Size = 8;\\r\\n    uint256 internal constant uint128Size = 16;\\r\\n    uint256 internal constant uint256Size = 32;\\r\\n    uint256 internal constant addressSize = 20;\\r\\n    /**\\r\\n     * Bits in 12 bytes.\\r\\n     */\\r\\n    uint256 private constant bytes12Bits = 96;\\r\\n\\r\\n    function slice(bytes memory buffer, uint256 startIndex, uint256 length) internal pure returns (bytes memory) {\\r\\n        unchecked {\\r\\n            require(length + 31 >= length, \\\"slice_overflow\\\");\\r\\n        }\\r\\n        require(buffer.length >= startIndex + length, \\\"slice_outOfBounds\\\");\\r\\n\\r\\n        bytes memory tempBytes;\\r\\n\\r\\n        assembly (\\\"memory-safe\\\") {\\r\\n            // Get a location of some free memory and store it in tempBytes as\\r\\n            // Solidity does for memory variables.\\r\\n            tempBytes := mload(freeMemoryPtr)\\r\\n\\r\\n            switch iszero(length)\\r\\n            case 0 {\\r\\n                // The first word of the slice result is potentially a partial\\r\\n                // word read from the original array. To read it, we calculate\\r\\n                // the length of that partial word and start copying that many\\r\\n                // bytes into the array. The first word we copy will start with\\r\\n                // data we don't care about, but the last `lengthmod` bytes will\\r\\n                // land at the beginning of the contents of the new array. When\\r\\n                // we're done copying, we overwrite the full first word with\\r\\n                // the actual length of the slice.\\r\\n                let lengthmod := and(length, maskModulo32)\\r\\n                // The multiplication in the next line is necessary\\r\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\r\\n                // the following copy loop was copying the origin's length\\r\\n                // and then ending prematurely not copying everything it should.\\r\\n                let startOffset := add(lengthmod, mul(memoryWord, iszero(lengthmod)))\\r\\n\\r\\n                let dst := add(tempBytes, startOffset)\\r\\n                let end := add(dst, length)\\r\\n\\r\\n                for { let src := add(add(buffer, startOffset), startIndex) } lt(dst, end) {\\r\\n                    dst := add(dst, memoryWord)\\r\\n                    src := add(src, memoryWord)\\r\\n                } { mstore(dst, mload(src)) }\\r\\n\\r\\n                // Update free-memory pointer\\r\\n                // allocating the array padded to 32 bytes like the compiler does now\\r\\n                // Note that negating bitwise the `maskModulo32` produces a mask that aligns addressing to 32 bytes.\\r\\n                mstore(freeMemoryPtr, and(add(dst, maskModulo32), not(maskModulo32)))\\r\\n            }\\r\\n            //if we want a zero-length slice let's just return a zero-length array\\r\\n            default { mstore(freeMemoryPtr, add(tempBytes, memoryWord)) }\\r\\n\\r\\n            // Store the length of the buffer\\r\\n            // We need to do it even if the length is zero because Solidity does not garbage collect\\r\\n            mstore(tempBytes, length)\\r\\n        }\\r\\n\\r\\n        return tempBytes;\\r\\n    }\\r\\n\\r\\n    function toAddress(bytes memory buffer, uint256 startIndex) internal pure returns (address) {\\r\\n        require(buffer.length >= startIndex + addressSize, \\\"toAddress_outOfBounds\\\");\\r\\n        address tempAddress;\\r\\n\\r\\n        assembly (\\\"memory-safe\\\") {\\r\\n            // We want to shift into the lower 12 bytes and leave the upper 12 bytes clear.\\r\\n            tempAddress := shr(bytes12Bits, mload(add(add(buffer, memoryWord), startIndex)))\\r\\n        }\\r\\n\\r\\n        return tempAddress;\\r\\n    }\\r\\n\\r\\n    function toUint8(bytes memory buffer, uint256 startIndex) internal pure returns (uint8) {\\r\\n        require(buffer.length > startIndex, \\\"toUint8_outOfBounds\\\");\\r\\n\\r\\n        // Note that `endIndex == startOffset` for a given buffer due to the 32 bytes at the start that store the length.\\r\\n        uint256 startOffset = startIndex + uint8Size;\\r\\n        uint8 tempUint;\\r\\n        assembly (\\\"memory-safe\\\") {\\r\\n            tempUint := mload(add(buffer, startOffset))\\r\\n        }\\r\\n        return tempUint;\\r\\n    }\\r\\n\\r\\n    function toUint16(bytes memory buffer, uint256 startIndex) internal pure returns (uint16) {\\r\\n        uint256 endIndex = startIndex + uint16Size;\\r\\n        require(buffer.length >= endIndex, \\\"toUint16_outOfBounds\\\");\\r\\n\\r\\n        uint16 tempUint;\\r\\n        assembly (\\\"memory-safe\\\") {\\r\\n            // Note that `endIndex == startOffset` for a given buffer due to the 32 bytes at the start that store the length.\\r\\n            tempUint := mload(add(buffer, endIndex))\\r\\n        }\\r\\n        return tempUint;\\r\\n    }\\r\\n\\r\\n    function toUint32(bytes memory buffer, uint256 startIndex) internal pure returns (uint32) {\\r\\n        uint256 endIndex = startIndex + uint32Size;\\r\\n        require(buffer.length >= endIndex, \\\"toUint32_outOfBounds\\\");\\r\\n\\r\\n        uint32 tempUint;\\r\\n        assembly (\\\"memory-safe\\\") {\\r\\n            // Note that `endIndex == startOffset` for a given buffer due to the 32 bytes at the start that store the length.\\r\\n            tempUint := mload(add(buffer, endIndex))\\r\\n        }\\r\\n        return tempUint;\\r\\n    }\\r\\n\\r\\n    function toUint64(bytes memory buffer, uint256 startIndex) internal pure returns (uint64) {\\r\\n        uint256 endIndex = startIndex + uint64Size;\\r\\n        require(buffer.length >= endIndex, \\\"toUint64_outOfBounds\\\");\\r\\n\\r\\n        uint64 tempUint;\\r\\n        assembly (\\\"memory-safe\\\") {\\r\\n            // Note that `endIndex == startOffset` for a given buffer due to the 32 bytes at the start that store the length.\\r\\n            tempUint := mload(add(buffer, endIndex))\\r\\n        }\\r\\n        return tempUint;\\r\\n    }\\r\\n\\r\\n    function toUint128(bytes memory buffer, uint256 startIndex) internal pure returns (uint128) {\\r\\n        uint256 endIndex = startIndex + uint128Size;\\r\\n        require(buffer.length >= endIndex, \\\"toUint128_outOfBounds\\\");\\r\\n\\r\\n        uint128 tempUint;\\r\\n        assembly (\\\"memory-safe\\\") {\\r\\n            // Note that `endIndex == startOffset` for a given buffer due to the 32 bytes at the start that store the length.\\r\\n            tempUint := mload(add(buffer, endIndex))\\r\\n        }\\r\\n        return tempUint;\\r\\n    }\\r\\n\\r\\n    function toUint256(bytes memory buffer, uint256 startIndex) internal pure returns (uint256) {\\r\\n        uint256 endIndex = startIndex + uint256Size;\\r\\n        require(buffer.length >= endIndex, \\\"toUint256_outOfBounds\\\");\\r\\n\\r\\n        uint256 tempUint;\\r\\n        assembly (\\\"memory-safe\\\") {\\r\\n            // Note that `endIndex == startOffset` for a given buffer due to the 32 bytes at the start that store the length.\\r\\n            tempUint := mload(add(buffer, endIndex))\\r\\n        }\\r\\n        return tempUint;\\r\\n    }\\r\\n\\r\\n    function toBytes32(bytes memory buffer, uint256 startIndex) internal pure returns (bytes32) {\\r\\n        uint256 endIndex = startIndex + uint256Size;\\r\\n        require(buffer.length >= endIndex, \\\"toBytes32_outOfBounds\\\");\\r\\n\\r\\n        bytes32 tempBytes32;\\r\\n        assembly (\\\"memory-safe\\\") {\\r\\n            // Note that `endIndex == startOffset` for a given buffer due to the 32 bytes at the start that store the length.\\r\\n            tempBytes32 := mload(add(buffer, endIndex))\\r\\n        }\\r\\n        return tempBytes32;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x075150a5939d2c00245b8e1ec6252db441fd4c345f8f1a09159c8446573ae4c8\",\"license\":\"Unlicense\"}},\"version\":1}",
  "bytecode": "0x610100604052600180546001600160c01b0316905534801561002057600080fd5b50604051612bef380380612bef83398101604081905261003f91610123565b600080546001600160a01b0319163390811782556040519091907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908290a36001600160a01b0384166100ad5760405162461bcd60e51b81526004016100a490610177565b60405180910390fd5b6001600160a01b0380851660805283166100d95760405162461bcd60e51b81526004016100a490610177565b6001600160a01b0392831660a05290821660c0521660e052506001805463ffffffff60a01b19169055610193565b80516001600160a01b038116811461011e57600080fd5b919050565b6000806000806080858703121561013957600080fd5b61014285610107565b935061015060208601610107565b925061015e60408601610107565b915061016c60608601610107565b905092959194509250565b6020808252600290820152615a4160f01b604082015260600190565b60805160a05160c05160e051612997610258600039600081816103fd0152818161062f015281816118a9015261192e0152600081816102e401528181610e9a015281816110500152818161114c015261122d0152600081816103a9015281816104d0015281816105920152818161072c0152610d3e015260008181610318015281816104500152818161090901528181610a1001528181610b3a01528181610c5801528181610e0a015281816112b7015281816114d1015261180301526129976000f3fe6080604052600436106101105760003560e01c80630505c8c914610115578063091d2788146101455780630963d30e1461016a578063197c6e771461018c5780632ec9c883146101ca578063342dc1e5146101f5578063354b606a146102155780634316dcd3146102285780634fd686c81461023d578063529dca32146102645780635beede08146102775780635f2934d31461028c578063757f3e721461029f57806378af9972146102bf5780638406c079146102d257806384acd1bb14610306578063a15ad0771461033a578063a4b239801461035a578063b850509a1461036f578063c6328a4614610397578063db04e81d146103cb578063dd6522aa146103eb578063e9fa31621461041f575b600080fd5b34801561012157600080fd5b506000546001600160a01b03165b60405161013c9190611b7a565b60405180910390f35b34801561015157600080fd5b5061015c620f424081565b60405190815260200161013c565b34801561017657600080fd5b5061018a610185366004611cbf565b610436565b005b34801561019857600080fd5b506101ac6101a7366004611cbf565b610820565b60408051825160ff168152602092830151928101929092520161013c565b6101dd6101d8366004611d28565b610904565b6040516001600160401b03909116815260200161013c565b34801561020157600080fd5b5061018a610210366004611da4565b610c13565b61018a610223366004611dd0565b610c54565b34801561023457600080fd5b5061015c610e06565b34801561024957600080fd5b5061025260c881565b60405160ff909116815260200161013c565b61018a610272366004611e57565b610e8f565b34801561028357600080fd5b5061018a610fd0565b61018a61029a366004611f48565b611036565b3480156102ab57600080fd5b5061015c6102ba366004611fba565b611213565b61018a6102cd366004611fde565b6112b0565b3480156102de57600080fd5b5061012f7f000000000000000000000000000000000000000000000000000000000000000081565b34801561031257600080fd5b5061012f7f000000000000000000000000000000000000000000000000000000000000000081565b34801561034657600080fd5b5061018a610355366004612050565b6116ec565b34801561036657600080fd5b5061018a61179d565b34801561037b57600080fd5b506103846117ff565b60405161ffff909116815260200161013c565b3480156103a357600080fd5b5061012f7f000000000000000000000000000000000000000000000000000000000000000081565b3480156103d757600080fd5b5061012f6103e636600461206d565b611883565b3480156103f757600080fd5b5061012f7f000000000000000000000000000000000000000000000000000000000000000081565b34801561042b57600080fd5b5061015c6202a30081565b60405163a9e1189360e01b81526000906001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063a9e11893906104859085906004016120ed565b600060405180830381865afa1580156104a2573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526104ca9190810190612340565b905060007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663ea63738d8360e001516040518263ffffffff1660e01b815260040161051e91906120ed565b600060405180830381865afa15801561053b573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526105639190810190612374565b60608101516040808301519051630ff8f14360e11b815261ffff909216600483015260248201529091506000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690631ff1e28690604401602060405180830381865afa1580156105e1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610605919061243f565b9050816060015161ffff16600114801561062657506001600160a01b038116155b156106c55760007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316639e68b129600585604001516040518363ffffffff1660e01b815260040161068092919061245c565b602060405180830381865afa15801561069d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106c19190612472565b9150505b6001600160a01b0381166107155760405162461bcd60e51b81526020600482015260126024820152711d1bdad95b881b9bdd08185d1d195cdd195960721b60448201526064015b60405180910390fd5b60405163c3f511c160e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063c3f511c1906107619087906004016120ed565b6000604051808303816000875af1158015610780573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526107a8919081019061248b565b506020808301516080850151606086015161ffff16600090815260039093526040909220549091146107ec5760405162461bcd60e51b815260040161070c906124bf565b60006107fb8460e00151610820565b60208101519091506108176001600160a01b03851682856119b0565b50505050505050565b604080518082019091526000808252602082015260006108408382611a14565b60ff168083526001146108895760405162461bcd60e51b81526020600482015260116024820152701a5b9d985b1a59081c185e5b1bd8591251607a1b604482015260640161070c565b610894600182612507565b90506108a08382611a74565b6020808401919091526108b39082612507565b9050825181146108fe5760405162461bcd60e51b81526020600482015260166024820152750d2dcecc2d8d2c840e0c2f2d8dec2c840d8cadccee8d60531b604482015260640161070c565b50919050565b6000807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316631a90a2196040518163ffffffff1660e01b8152600401602060405180830381865afa158015610965573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109899190612472565b9050803410156109ab5760405162461bcd60e51b815260040161070c9061251a565b6109c96001600160a01b03871633306001600160401b038916611ad7565b3360009081526002602090815260408083206001600160a01b038a811685529083528184206001600160401b038a1690558151634d4502c960e11b815291518893889342937f00000000000000000000000000000000000000000000000000000000000000001692639a8a0592926004808401939192918290030181865afa158015610a59573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a7d9190612565565b6040516001600160c01b031960c095861b8116602083015293851b8416602882015291841b831660308301526001600160f01b031960f09190911b1660388201526001600160601b031933606090811b8216603a8401528b901b16605a8201529188901b16607a82015260820160408051601f1981840301815282820182526001808452602084810183905282519351929550600093610b21939091879101612582565b60408051808303601f19018152919052600180549192507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169163b19a437e918791600160a01b900463ffffffff16906014610b84836125cc565b91906101000a81548163ffffffff021916908363ffffffff1602179055508460c86040518563ffffffff1660e01b8152600401610bc3939291906125f1565b60206040518083038185885af1158015610be1573d6000803e3d6000fd5b50505050506040513d601f19601f82011682018060405250810190610c069190612623565b9998505050505050505050565b6000546001600160a01b03163314610c3d5760405162461bcd60e51b815260040161070c90612640565b61ffff909116600090815260036020526040902055565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316631a90a2196040518163ffffffff1660e01b8152600401602060405180830381865afa158015610cb4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cd89190612472565b905080341015610d1e5760405162461bcd60e51b8152602060048201526011602482015270496e76616c6964206d73672076616c756560781b604482015260640161070c565b610d3c6001600160a01b03861633306001600160401b038816611ad7565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663c5a5ebda86868686600160149054906101000a900463ffffffff168c604051602001610d939190611b7a565b6040516020818303038152906040526040518763ffffffff1660e01b8152600401610dc396959493929190612675565b6020604051808303816000875af1158015610de2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108179190612623565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316631a90a2196040518163ffffffff1660e01b8152600401602060405180830381865afa158015610e66573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e8a9190612472565b905090565b336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610ef55760405162461bcd60e51b815260206004820152600b60248201526a2737ba103932b630bcb2b960a91b604482015260640161070c565b61ffff8216600090815260036020526040902054829084908114610f535760405162461bcd60e51b81526020600482015260156024820152742737ba103932b3b4b9ba32b932b21039b2b73232b960591b604482015260640161070c565b600087806020019051810190610f6991906126d1565b5050604080516001600160a01b038316815261ffff8c1660208201529081018c90529095507fed57b41026cbcb13384f314fbbf57a49654f4ac69be150d2cbfcd49d10f87fc394506060019250610fbe915050565b60405180910390a15050505050505050565b6001546001600160a01b03163314610fe757600080fd5b600154600080546040516001600160a01b03938416939091169160008051602061294283398151915291a3600154600080546001600160a01b0319166001600160a01b03909216919091179055565b60405163c23ee3c360e01b81526000906001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063c23ee3c39061108c9086908590620f424090600401612725565b6040805180830381865afa1580156110a8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110cc9190612741565b509050803410156110ef5760405162461bcd60e51b815260040161070c9061251a565b604080516020810188905290810186905260608181018690524260808301526001600160601b031933821b811660a0840152908a901b1660c082015260e081018890526000906101000160405160208183030381529060405290507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316638fecdd02838686853360405160200161118f929190612765565b6040516020818303038152906040526000620f42406040518763ffffffff1660e01b81526004016111c495949392919061278f565b60206040518083038185885af11580156111e2573d6000803e3d6000fd5b50505050506040513d601f19601f820116820180604052508101906112079190612623565b50505050505050505050565b60405163c23ee3c360e01b81526000906001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063c23ee3c3906112699085908590620f424090600401612725565b6040805180830381865afa158015611285573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112a99190612741565b5092915050565b60008060007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663c0fd8bde86866040518363ffffffff1660e01b81526004016113039291906127d1565b600060405180830381865afa158015611320573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526113489190810190612800565b92509250925081819061136e5760405162461bcd60e51b815260040161070c91906120ed565b506080830151606084015161ffff16600090815260036020526040902054146113a95760405162461bcd60e51b815260040161070c906124bf565b60015460a08401516001600160401b03600160c01b90920482169116101561140d5760405162461bcd60e51b815260206004820152601760248201527624b73b30b634b21029b2b8bab2b731b290373ab6b132b960491b604482015260640161070c565b60a083015161141d906001612893565b600160186101000a8154816001600160401b0302191690836001600160401b03160217905550426202a300846020015163ffffffff1661145d9190612507565b10156114a55760405162461bcd60e51b815260206004820152601760248201527613595cdcd859d9481b9bc81b1bdb99d95c881d985b1a59604a1b604482015260640161070c565b60008060008060008760e001518060200190518101906114c591906128b2565b945094509450945094507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316639a8a05926040518163ffffffff1660e01b8152600401602060405180830381865afa15801561152d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115519190612565565b61ffff168261ffff16146115985760405162461bcd60e51b815260206004820152600e60248201526d15dc9bdb99c818da185a5b88125960921b604482015260640161070c565b6001600160601b03193060601b1681146115e45760405162461bcd60e51b815260206004820152600d60248201526c57726f6e67206164647265737360981b604482015260640161070c565b6001600160a01b038086166000908152600260209081526040808320938816835292905220548381101561164b5760405162461bcd60e51b815260206004820152600e60248201526d125b9d985b1a5908185b5bdd5b9d60921b604482015260640161070c565b6001600160a01b03808716600090815260026020908152604080832093891683529290529081208054869290611682908490612913565b9091555061169c90506001600160a01b03861687866119b0565b846001600160a01b03167f9dd3045b6df532ed81beb2a333cec6249dafd3c2fc54c80c50155cb0e1a0ba1e856040516116d791815260200190565b60405180910390a25050505050505050505050565b6000546001600160a01b031633146117165760405162461bcd60e51b815260040161070c90612640565b6001600160a01b03811661177b5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b606482015260840161070c565b600180546001600160a01b0319166001600160a01b0392909216919091179055565b6000546001600160a01b031633146117c75760405162461bcd60e51b815260040161070c90612640565b600080546040516001600160a01b0390911690600080516020612942833981519152908390a3600080546001600160a01b0319169055565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316639a8a05926040518163ffffffff1660e01b8152600401602060405180830381865afa15801561185f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e8a9190612565565b60405163134f89bd60e01b815261ffff8216600482015260009081906001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063134f89bd90602401602060405180830381865afa1580156118f0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119149190612926565b604051639e68b12960e01b81529091506001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690639e68b12990611965908490889060040161245c565b602060405180830381865afa158015611982573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119a69190612472565b9150505b92915050565b6040516001600160a01b03838116602483015260448201839052611a0f91859182169063a9059cbb906064015b604051602081830303815290604052915060e01b6020820180516001600160e01b038381831617835250505050611b16565b505050565b600081835111611a5c5760405162461bcd60e51b8152602060048201526013602482015272746f55696e74385f6f75744f66426f756e647360681b604482015260640161070c565b6000611a69600184612507565b909301519392505050565b600080611a82602084612507565b90508084511015611acd5760405162461bcd60e51b8152602060048201526015602482015274746f427974657333325f6f75744f66426f756e647360581b604482015260640161070c565b9092015192915050565b6040516001600160a01b038481166024830152838116604483015260648201839052611b109186918216906323b872dd906084016119dd565b50505050565b600080602060008451602086016000885af180611b39576040513d6000823e3d81fd5b50506000513d91508115611b51578060011415611b5e565b6001600160a01b0384163b155b15611b105783604051635274afe760e01b815260040161070c91905b6001600160a01b0391909116815260200190565b634e487b7160e01b600052604160045260246000fd5b604051608081016001600160401b0381118282101715611bc657611bc6611b8e565b60405290565b60405161016081016001600160401b0381118282101715611bc657611bc6611b8e565b60405161010081016001600160401b0381118282101715611bc657611bc6611b8e565b604051601f8201601f191681016001600160401b0381118282101715611c3a57611c3a611b8e565b604052919050565b60006001600160401b03821115611c5b57611c5b611b8e565b50601f01601f191660200190565b600082601f830112611c7a57600080fd5b8135611c8d611c8882611c42565b611c12565b818152846020838601011115611ca257600080fd5b816020850160208301376000918101602001919091529392505050565b600060208284031215611cd157600080fd5b81356001600160401b03811115611ce757600080fd5b611cf384828501611c69565b949350505050565b6001600160a01b0381168114611d1057600080fd5b50565b6001600160401b0381168114611d1057600080fd5b60008060008060808587031215611d3e57600080fd5b8435611d4981611cfb565b93506020850135611d5981611d13565b92506040850135611d6981611d13565b91506060850135611d7981611d13565b939692955090935050565b61ffff81168114611d1057600080fd5b8035611d9f81611d84565b919050565b60008060408385031215611db757600080fd5b8235611dc281611d84565b946020939093013593505050565b600080600080600060a08688031215611de857600080fd5b8535611df381611cfb565b94506020860135611e0381611cfb565b93506040860135611e1381611d13565b92506060860135611e2381611d84565b949793965091946080013592915050565b60006001600160401b03821115611e4d57611e4d611b8e565b5060051b60200190565b600080600080600060a08688031215611e6f57600080fd5b85356001600160401b03811115611e8557600080fd5b611e9188828901611c69565b95505060208601356001600160401b03811115611ead57600080fd5b8601601f81018813611ebe57600080fd5b8035611ecc611c8882611e34565b8082825260208201915060208360051b85010192508a831115611eee57600080fd5b602084015b83811015611f2f5780356001600160401b03811115611f1157600080fd5b611f208d602083890101611c69565b84525060209283019201611ef3565b50965050505060408601359250611e2360608701611d94565b600080600080600080600060e0888a031215611f6357600080fd5b8735611f6e81611cfb565b96506020880135955060408801359450606088013593506080880135925060a0880135611f9a81611d84565b915060c0880135611faa81611cfb565b8091505092959891949750929550565b600060208284031215611fcc57600080fd5b8135611fd781611d84565b9392505050565b60008060208385031215611ff157600080fd5b82356001600160401b0381111561200757600080fd5b8301601f8101851361201857600080fd5b80356001600160401b0381111561202e57600080fd5b85602082840101111561204057600080fd5b6020919091019590945092505050565b60006020828403121561206257600080fd5b8135611fd781611cfb565b6000806040838503121561208057600080fd5b82359150602083013561209281611d84565b809150509250929050565b60005b838110156120b85781810151838201526020016120a0565b50506000910152565b600081518084526120d981602086016020860161209d565b601f01601f19169290920160200192915050565b602081526000611fd760208301846120c1565b805160ff81168114611d9f57600080fd5b805163ffffffff81168114611d9f57600080fd5b8051611d9f81611d84565b8051611d9f81611d13565b6000612149611c8884611c42565b905082815283838301111561215d57600080fd5b611fd783602083018461209d565b600082601f83011261217c57600080fd5b611fd78383516020850161213b565b600082601f83011261219c57600080fd5b81516121aa611c8882611e34565b8082825260208201915060208360071b8601019250858311156121cc57600080fd5b602085015b8381101561223157608081880312156121e957600080fd5b6121f1611ba4565b815181526020808301519082015261220b60408301612100565b604082015261221c60608301612100565b606082015283526020909201916080016121d1565b5095945050505050565b6000610160828403121561224e57600080fd5b612256611bcc565b905061226182612100565b815261226f60208301612111565b602082015261228060408301612111565b604082015261229160608301612125565b6060820152608082810151908201526122ac60a08301612130565b60a08201526122bd60c08301612100565b60c082015260e08201516001600160401b038111156122db57600080fd5b6122e78482850161216b565b60e0830152506122fa6101008301612111565b6101008201526101208201516001600160401b0381111561231a57600080fd5b6123268482850161218b565b610120830152506101409182015191810191909152919050565b60006020828403121561235257600080fd5b81516001600160401b0381111561236857600080fd5b611cf38482850161223b565b60006020828403121561238657600080fd5b81516001600160401b0381111561239c57600080fd5b820161010081850312156123af57600080fd5b6123b7611bef565b6123c082612100565b815260208281015190820152604080830151908201526123e260608301612125565b6060820152608082810151908201526123fd60a08301612125565b60a082015260c0828101519082015260e08201516001600160401b0381111561242557600080fd5b6124318682850161216b565b60e083015250949350505050565b60006020828403121561245157600080fd5b8151611fd781611cfb565b63ffffffff929092168252602082015260400190565b60006020828403121561248457600080fd5b5051919050565b60006020828403121561249d57600080fd5b81516001600160401b038111156124b357600080fd5b611cf38482850161216b565b602080825260189082015277496e76616c696420456d697474657220416464726573732160401b604082015260600190565b634e487b7160e01b600052601160045260246000fd5b808201808211156119aa576119aa6124f1565b6020808252602b908201527f496e73756666696369656e742066756e647320666f722063726f73732d63686160408201526a696e2064656c697665727960a81b606082015260800190565b60006020828403121561257757600080fd5b8151611fd781611d84565b60f884901b6001600160f81b031916815260f083901b6001600160f01b031916600182015281516000906125bd81600385016020870161209d565b91909101600301949350505050565b600063ffffffff821663ffffffff81036125e8576125e86124f1565b60010192915050565b63ffffffff8416815260606020820152600061261060608301856120c1565b905060ff83166040830152949350505050565b60006020828403121561263557600080fd5b8151611fd781611d13565b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604082015260600190565b6001600160a01b03871681526001600160401b038616602082015261ffff851660408201526060810184905263ffffffff8316608082015260c060a082018190526000906126c5908301846120c1565b98975050505050505050565b600080600080600080600060e0888a0312156126ec57600080fd5b5050855160208701516040880151606089015160808a015160a08b015160c0909b0151949c939b50919990985090965094509092509050565b61ffff9390931683526020830191909152604082015260600190565b6000806040838503121561275457600080fd5b505080516020909101519092909150565b60408152600061277860408301856120c1565b905060018060a01b03831660208301529392505050565b61ffff861681526001600160a01b038516602082015260a0604082018190526000906127bd908301866120c1565b606083019490945250608001529392505050565b60208152816020820152818360408301376000818301604090810191909152601f909201601f19160101919050565b60008060006060848603121561281557600080fd5b83516001600160401b0381111561282b57600080fd5b6128378682870161223b565b9350506020840151801515811461284d57600080fd5b60408501519092506001600160401b0381111561286957600080fd5b8401601f8101861361287a57600080fd5b6128898682516020840161213b565b9150509250925092565b6001600160401b0381811683821601908111156119aa576119aa6124f1565b600080600080600060a086880312156128ca57600080fd5b85516128d581611cfb565b60208701519095506128e681611cfb565b6040870151606088015191955093506128fe81611d84565b60809690960151949793965091949392915050565b818103818111156119aa576119aa6124f1565b60006020828403121561293857600080fd5b611fd78261211156fe8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0a26469706673582212203fbcce1543c61df898117a462f85225dc3196cf40eff273ca2df96058fdb0ed364736f6c634300081b0033",
  "deployedBytecode": "0x6080604052600436106101105760003560e01c80630505c8c914610115578063091d2788146101455780630963d30e1461016a578063197c6e771461018c5780632ec9c883146101ca578063342dc1e5146101f5578063354b606a146102155780634316dcd3146102285780634fd686c81461023d578063529dca32146102645780635beede08146102775780635f2934d31461028c578063757f3e721461029f57806378af9972146102bf5780638406c079146102d257806384acd1bb14610306578063a15ad0771461033a578063a4b239801461035a578063b850509a1461036f578063c6328a4614610397578063db04e81d146103cb578063dd6522aa146103eb578063e9fa31621461041f575b600080fd5b34801561012157600080fd5b506000546001600160a01b03165b60405161013c9190611b7a565b60405180910390f35b34801561015157600080fd5b5061015c620f424081565b60405190815260200161013c565b34801561017657600080fd5b5061018a610185366004611cbf565b610436565b005b34801561019857600080fd5b506101ac6101a7366004611cbf565b610820565b60408051825160ff168152602092830151928101929092520161013c565b6101dd6101d8366004611d28565b610904565b6040516001600160401b03909116815260200161013c565b34801561020157600080fd5b5061018a610210366004611da4565b610c13565b61018a610223366004611dd0565b610c54565b34801561023457600080fd5b5061015c610e06565b34801561024957600080fd5b5061025260c881565b60405160ff909116815260200161013c565b61018a610272366004611e57565b610e8f565b34801561028357600080fd5b5061018a610fd0565b61018a61029a366004611f48565b611036565b3480156102ab57600080fd5b5061015c6102ba366004611fba565b611213565b61018a6102cd366004611fde565b6112b0565b3480156102de57600080fd5b5061012f7f000000000000000000000000000000000000000000000000000000000000000081565b34801561031257600080fd5b5061012f7f000000000000000000000000000000000000000000000000000000000000000081565b34801561034657600080fd5b5061018a610355366004612050565b6116ec565b34801561036657600080fd5b5061018a61179d565b34801561037b57600080fd5b506103846117ff565b60405161ffff909116815260200161013c565b3480156103a357600080fd5b5061012f7f000000000000000000000000000000000000000000000000000000000000000081565b3480156103d757600080fd5b5061012f6103e636600461206d565b611883565b3480156103f757600080fd5b5061012f7f000000000000000000000000000000000000000000000000000000000000000081565b34801561042b57600080fd5b5061015c6202a30081565b60405163a9e1189360e01b81526000906001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063a9e11893906104859085906004016120ed565b600060405180830381865afa1580156104a2573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526104ca9190810190612340565b905060007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663ea63738d8360e001516040518263ffffffff1660e01b815260040161051e91906120ed565b600060405180830381865afa15801561053b573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526105639190810190612374565b60608101516040808301519051630ff8f14360e11b815261ffff909216600483015260248201529091506000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690631ff1e28690604401602060405180830381865afa1580156105e1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610605919061243f565b9050816060015161ffff16600114801561062657506001600160a01b038116155b156106c55760007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316639e68b129600585604001516040518363ffffffff1660e01b815260040161068092919061245c565b602060405180830381865afa15801561069d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106c19190612472565b9150505b6001600160a01b0381166107155760405162461bcd60e51b81526020600482015260126024820152711d1bdad95b881b9bdd08185d1d195cdd195960721b60448201526064015b60405180910390fd5b60405163c3f511c160e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063c3f511c1906107619087906004016120ed565b6000604051808303816000875af1158015610780573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526107a8919081019061248b565b506020808301516080850151606086015161ffff16600090815260039093526040909220549091146107ec5760405162461bcd60e51b815260040161070c906124bf565b60006107fb8460e00151610820565b60208101519091506108176001600160a01b03851682856119b0565b50505050505050565b604080518082019091526000808252602082015260006108408382611a14565b60ff168083526001146108895760405162461bcd60e51b81526020600482015260116024820152701a5b9d985b1a59081c185e5b1bd8591251607a1b604482015260640161070c565b610894600182612507565b90506108a08382611a74565b6020808401919091526108b39082612507565b9050825181146108fe5760405162461bcd60e51b81526020600482015260166024820152750d2dcecc2d8d2c840e0c2f2d8dec2c840d8cadccee8d60531b604482015260640161070c565b50919050565b6000807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316631a90a2196040518163ffffffff1660e01b8152600401602060405180830381865afa158015610965573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109899190612472565b9050803410156109ab5760405162461bcd60e51b815260040161070c9061251a565b6109c96001600160a01b03871633306001600160401b038916611ad7565b3360009081526002602090815260408083206001600160a01b038a811685529083528184206001600160401b038a1690558151634d4502c960e11b815291518893889342937f00000000000000000000000000000000000000000000000000000000000000001692639a8a0592926004808401939192918290030181865afa158015610a59573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a7d9190612565565b6040516001600160c01b031960c095861b8116602083015293851b8416602882015291841b831660308301526001600160f01b031960f09190911b1660388201526001600160601b031933606090811b8216603a8401528b901b16605a8201529188901b16607a82015260820160408051601f1981840301815282820182526001808452602084810183905282519351929550600093610b21939091879101612582565b60408051808303601f19018152919052600180549192507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169163b19a437e918791600160a01b900463ffffffff16906014610b84836125cc565b91906101000a81548163ffffffff021916908363ffffffff1602179055508460c86040518563ffffffff1660e01b8152600401610bc3939291906125f1565b60206040518083038185885af1158015610be1573d6000803e3d6000fd5b50505050506040513d601f19601f82011682018060405250810190610c069190612623565b9998505050505050505050565b6000546001600160a01b03163314610c3d5760405162461bcd60e51b815260040161070c90612640565b61ffff909116600090815260036020526040902055565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316631a90a2196040518163ffffffff1660e01b8152600401602060405180830381865afa158015610cb4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cd89190612472565b905080341015610d1e5760405162461bcd60e51b8152602060048201526011602482015270496e76616c6964206d73672076616c756560781b604482015260640161070c565b610d3c6001600160a01b03861633306001600160401b038816611ad7565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663c5a5ebda86868686600160149054906101000a900463ffffffff168c604051602001610d939190611b7a565b6040516020818303038152906040526040518763ffffffff1660e01b8152600401610dc396959493929190612675565b6020604051808303816000875af1158015610de2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108179190612623565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316631a90a2196040518163ffffffff1660e01b8152600401602060405180830381865afa158015610e66573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e8a9190612472565b905090565b336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610ef55760405162461bcd60e51b815260206004820152600b60248201526a2737ba103932b630bcb2b960a91b604482015260640161070c565b61ffff8216600090815260036020526040902054829084908114610f535760405162461bcd60e51b81526020600482015260156024820152742737ba103932b3b4b9ba32b932b21039b2b73232b960591b604482015260640161070c565b600087806020019051810190610f6991906126d1565b5050604080516001600160a01b038316815261ffff8c1660208201529081018c90529095507fed57b41026cbcb13384f314fbbf57a49654f4ac69be150d2cbfcd49d10f87fc394506060019250610fbe915050565b60405180910390a15050505050505050565b6001546001600160a01b03163314610fe757600080fd5b600154600080546040516001600160a01b03938416939091169160008051602061294283398151915291a3600154600080546001600160a01b0319166001600160a01b03909216919091179055565b60405163c23ee3c360e01b81526000906001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063c23ee3c39061108c9086908590620f424090600401612725565b6040805180830381865afa1580156110a8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110cc9190612741565b509050803410156110ef5760405162461bcd60e51b815260040161070c9061251a565b604080516020810188905290810186905260608181018690524260808301526001600160601b031933821b811660a0840152908a901b1660c082015260e081018890526000906101000160405160208183030381529060405290507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316638fecdd02838686853360405160200161118f929190612765565b6040516020818303038152906040526000620f42406040518763ffffffff1660e01b81526004016111c495949392919061278f565b60206040518083038185885af11580156111e2573d6000803e3d6000fd5b50505050506040513d601f19601f820116820180604052508101906112079190612623565b50505050505050505050565b60405163c23ee3c360e01b81526000906001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063c23ee3c3906112699085908590620f424090600401612725565b6040805180830381865afa158015611285573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112a99190612741565b5092915050565b60008060007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663c0fd8bde86866040518363ffffffff1660e01b81526004016113039291906127d1565b600060405180830381865afa158015611320573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526113489190810190612800565b92509250925081819061136e5760405162461bcd60e51b815260040161070c91906120ed565b506080830151606084015161ffff16600090815260036020526040902054146113a95760405162461bcd60e51b815260040161070c906124bf565b60015460a08401516001600160401b03600160c01b90920482169116101561140d5760405162461bcd60e51b815260206004820152601760248201527624b73b30b634b21029b2b8bab2b731b290373ab6b132b960491b604482015260640161070c565b60a083015161141d906001612893565b600160186101000a8154816001600160401b0302191690836001600160401b03160217905550426202a300846020015163ffffffff1661145d9190612507565b10156114a55760405162461bcd60e51b815260206004820152601760248201527613595cdcd859d9481b9bc81b1bdb99d95c881d985b1a59604a1b604482015260640161070c565b60008060008060008760e001518060200190518101906114c591906128b2565b945094509450945094507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316639a8a05926040518163ffffffff1660e01b8152600401602060405180830381865afa15801561152d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115519190612565565b61ffff168261ffff16146115985760405162461bcd60e51b815260206004820152600e60248201526d15dc9bdb99c818da185a5b88125960921b604482015260640161070c565b6001600160601b03193060601b1681146115e45760405162461bcd60e51b815260206004820152600d60248201526c57726f6e67206164647265737360981b604482015260640161070c565b6001600160a01b038086166000908152600260209081526040808320938816835292905220548381101561164b5760405162461bcd60e51b815260206004820152600e60248201526d125b9d985b1a5908185b5bdd5b9d60921b604482015260640161070c565b6001600160a01b03808716600090815260026020908152604080832093891683529290529081208054869290611682908490612913565b9091555061169c90506001600160a01b03861687866119b0565b846001600160a01b03167f9dd3045b6df532ed81beb2a333cec6249dafd3c2fc54c80c50155cb0e1a0ba1e856040516116d791815260200190565b60405180910390a25050505050505050505050565b6000546001600160a01b031633146117165760405162461bcd60e51b815260040161070c90612640565b6001600160a01b03811661177b5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b606482015260840161070c565b600180546001600160a01b0319166001600160a01b0392909216919091179055565b6000546001600160a01b031633146117c75760405162461bcd60e51b815260040161070c90612640565b600080546040516001600160a01b0390911690600080516020612942833981519152908390a3600080546001600160a01b0319169055565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316639a8a05926040518163ffffffff1660e01b8152600401602060405180830381865afa15801561185f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e8a9190612565565b60405163134f89bd60e01b815261ffff8216600482015260009081906001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063134f89bd90602401602060405180830381865afa1580156118f0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119149190612926565b604051639e68b12960e01b81529091506001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690639e68b12990611965908490889060040161245c565b602060405180830381865afa158015611982573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119a69190612472565b9150505b92915050565b6040516001600160a01b03838116602483015260448201839052611a0f91859182169063a9059cbb906064015b604051602081830303815290604052915060e01b6020820180516001600160e01b038381831617835250505050611b16565b505050565b600081835111611a5c5760405162461bcd60e51b8152602060048201526013602482015272746f55696e74385f6f75744f66426f756e647360681b604482015260640161070c565b6000611a69600184612507565b909301519392505050565b600080611a82602084612507565b90508084511015611acd5760405162461bcd60e51b8152602060048201526015602482015274746f427974657333325f6f75744f66426f756e647360581b604482015260640161070c565b9092015192915050565b6040516001600160a01b038481166024830152838116604483015260648201839052611b109186918216906323b872dd906084016119dd565b50505050565b600080602060008451602086016000885af180611b39576040513d6000823e3d81fd5b50506000513d91508115611b51578060011415611b5e565b6001600160a01b0384163b155b15611b105783604051635274afe760e01b815260040161070c91905b6001600160a01b0391909116815260200190565b634e487b7160e01b600052604160045260246000fd5b604051608081016001600160401b0381118282101715611bc657611bc6611b8e565b60405290565b60405161016081016001600160401b0381118282101715611bc657611bc6611b8e565b60405161010081016001600160401b0381118282101715611bc657611bc6611b8e565b604051601f8201601f191681016001600160401b0381118282101715611c3a57611c3a611b8e565b604052919050565b60006001600160401b03821115611c5b57611c5b611b8e565b50601f01601f191660200190565b600082601f830112611c7a57600080fd5b8135611c8d611c8882611c42565b611c12565b818152846020838601011115611ca257600080fd5b816020850160208301376000918101602001919091529392505050565b600060208284031215611cd157600080fd5b81356001600160401b03811115611ce757600080fd5b611cf384828501611c69565b949350505050565b6001600160a01b0381168114611d1057600080fd5b50565b6001600160401b0381168114611d1057600080fd5b60008060008060808587031215611d3e57600080fd5b8435611d4981611cfb565b93506020850135611d5981611d13565b92506040850135611d6981611d13565b91506060850135611d7981611d13565b939692955090935050565b61ffff81168114611d1057600080fd5b8035611d9f81611d84565b919050565b60008060408385031215611db757600080fd5b8235611dc281611d84565b946020939093013593505050565b600080600080600060a08688031215611de857600080fd5b8535611df381611cfb565b94506020860135611e0381611cfb565b93506040860135611e1381611d13565b92506060860135611e2381611d84565b949793965091946080013592915050565b60006001600160401b03821115611e4d57611e4d611b8e565b5060051b60200190565b600080600080600060a08688031215611e6f57600080fd5b85356001600160401b03811115611e8557600080fd5b611e9188828901611c69565b95505060208601356001600160401b03811115611ead57600080fd5b8601601f81018813611ebe57600080fd5b8035611ecc611c8882611e34565b8082825260208201915060208360051b85010192508a831115611eee57600080fd5b602084015b83811015611f2f5780356001600160401b03811115611f1157600080fd5b611f208d602083890101611c69565b84525060209283019201611ef3565b50965050505060408601359250611e2360608701611d94565b600080600080600080600060e0888a031215611f6357600080fd5b8735611f6e81611cfb565b96506020880135955060408801359450606088013593506080880135925060a0880135611f9a81611d84565b915060c0880135611faa81611cfb565b8091505092959891949750929550565b600060208284031215611fcc57600080fd5b8135611fd781611d84565b9392505050565b60008060208385031215611ff157600080fd5b82356001600160401b0381111561200757600080fd5b8301601f8101851361201857600080fd5b80356001600160401b0381111561202e57600080fd5b85602082840101111561204057600080fd5b6020919091019590945092505050565b60006020828403121561206257600080fd5b8135611fd781611cfb565b6000806040838503121561208057600080fd5b82359150602083013561209281611d84565b809150509250929050565b60005b838110156120b85781810151838201526020016120a0565b50506000910152565b600081518084526120d981602086016020860161209d565b601f01601f19169290920160200192915050565b602081526000611fd760208301846120c1565b805160ff81168114611d9f57600080fd5b805163ffffffff81168114611d9f57600080fd5b8051611d9f81611d84565b8051611d9f81611d13565b6000612149611c8884611c42565b905082815283838301111561215d57600080fd5b611fd783602083018461209d565b600082601f83011261217c57600080fd5b611fd78383516020850161213b565b600082601f83011261219c57600080fd5b81516121aa611c8882611e34565b8082825260208201915060208360071b8601019250858311156121cc57600080fd5b602085015b8381101561223157608081880312156121e957600080fd5b6121f1611ba4565b815181526020808301519082015261220b60408301612100565b604082015261221c60608301612100565b606082015283526020909201916080016121d1565b5095945050505050565b6000610160828403121561224e57600080fd5b612256611bcc565b905061226182612100565b815261226f60208301612111565b602082015261228060408301612111565b604082015261229160608301612125565b6060820152608082810151908201526122ac60a08301612130565b60a08201526122bd60c08301612100565b60c082015260e08201516001600160401b038111156122db57600080fd5b6122e78482850161216b565b60e0830152506122fa6101008301612111565b6101008201526101208201516001600160401b0381111561231a57600080fd5b6123268482850161218b565b610120830152506101409182015191810191909152919050565b60006020828403121561235257600080fd5b81516001600160401b0381111561236857600080fd5b611cf38482850161223b565b60006020828403121561238657600080fd5b81516001600160401b0381111561239c57600080fd5b820161010081850312156123af57600080fd5b6123b7611bef565b6123c082612100565b815260208281015190820152604080830151908201526123e260608301612125565b6060820152608082810151908201526123fd60a08301612125565b60a082015260c0828101519082015260e08201516001600160401b0381111561242557600080fd5b6124318682850161216b565b60e083015250949350505050565b60006020828403121561245157600080fd5b8151611fd781611cfb565b63ffffffff929092168252602082015260400190565b60006020828403121561248457600080fd5b5051919050565b60006020828403121561249d57600080fd5b81516001600160401b038111156124b357600080fd5b611cf38482850161216b565b602080825260189082015277496e76616c696420456d697474657220416464726573732160401b604082015260600190565b634e487b7160e01b600052601160045260246000fd5b808201808211156119aa576119aa6124f1565b6020808252602b908201527f496e73756666696369656e742066756e647320666f722063726f73732d63686160408201526a696e2064656c697665727960a81b606082015260800190565b60006020828403121561257757600080fd5b8151611fd781611d84565b60f884901b6001600160f81b031916815260f083901b6001600160f01b031916600182015281516000906125bd81600385016020870161209d565b91909101600301949350505050565b600063ffffffff821663ffffffff81036125e8576125e86124f1565b60010192915050565b63ffffffff8416815260606020820152600061261060608301856120c1565b905060ff83166040830152949350505050565b60006020828403121561263557600080fd5b8151611fd781611d13565b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604082015260600190565b6001600160a01b03871681526001600160401b038616602082015261ffff851660408201526060810184905263ffffffff8316608082015260c060a082018190526000906126c5908301846120c1565b98975050505050505050565b600080600080600080600060e0888a0312156126ec57600080fd5b5050855160208701516040880151606089015160808a015160a08b015160c0909b0151949c939b50919990985090965094509092509050565b61ffff9390931683526020830191909152604082015260600190565b6000806040838503121561275457600080fd5b505080516020909101519092909150565b60408152600061277860408301856120c1565b905060018060a01b03831660208301529392505050565b61ffff861681526001600160a01b038516602082015260a0604082018190526000906127bd908301866120c1565b606083019490945250608001529392505050565b60208152816020820152818360408301376000818301604090810191909152601f909201601f19160101919050565b60008060006060848603121561281557600080fd5b83516001600160401b0381111561282b57600080fd5b6128378682870161223b565b9350506020840151801515811461284d57600080fd5b60408501519092506001600160401b0381111561286957600080fd5b8401601f8101861361287a57600080fd5b6128898682516020840161213b565b9150509250925092565b6001600160401b0381811683821601908111156119aa576119aa6124f1565b600080600080600060a086880312156128ca57600080fd5b85516128d581611cfb565b60208701519095506128e681611cfb565b6040870151606088015191955093506128fe81611d84565b60809690960151949793965091949392915050565b818103818111156119aa576119aa6124f1565b60006020828403121561293857600080fd5b611fd78261211156fe8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0a26469706673582212203fbcce1543c61df898117a462f85225dc3196cf40eff273ca2df96058fdb0ed364736f6c634300081b0033",
  "devdoc": {
    "errors": {
      "SafeERC20FailedOperation(address)": [
        {
          "details": "An operation with an ERC-20 token failed."
        }
      ]
    },
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "MESSAGE_TIME_OUT_SECONDS()": {
        "notice": "Message timeout in seconds: Time out needs to account for: - Finality time on source chain - Time for Wormhole validators to sign and make VAA available to relayers - Time to relay VAA to the target chain - Congestion on target chain leading to delayed inclusion of transaction in target chain Note that there is no way to alter this hard coded value. Including such a feature would require some governance structure and some minumum and maximum values."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 878,
        "contract": "contracts/WormholeBridge.sol:WormholeBridge",
        "label": "_policy",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 880,
        "contract": "contracts/WormholeBridge.sol:WormholeBridge",
        "label": "_newPolicy",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 1015,
        "contract": "contracts/WormholeBridge.sol:WormholeBridge",
        "label": "NONCE",
        "offset": 20,
        "slot": "1",
        "type": "t_uint32"
      },
      {
        "astId": 1024,
        "contract": "contracts/WormholeBridge.sol:WormholeBridge",
        "label": "minSequence",
        "offset": 24,
        "slot": "1",
        "type": "t_uint64"
      },
      {
        "astId": 1046,
        "contract": "contracts/WormholeBridge.sol:WormholeBridge",
        "label": "locked",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_address,t_mapping(t_address,t_uint256))"
      },
      {
        "astId": 1050,
        "contract": "contracts/WormholeBridge.sol:WormholeBridge",
        "label": "registeredSenders",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_uint16,t_bytes32)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_mapping(t_address,t_mapping(t_address,t_uint256))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_uint256)"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint16,t_bytes32)": {
        "encoding": "mapping",
        "key": "t_uint16",
        "label": "mapping(uint16 => bytes32)",
        "numberOfBytes": "32",
        "value": "t_bytes32"
      },
      "t_uint16": {
        "encoding": "inplace",
        "label": "uint16",
        "numberOfBytes": "2"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint32": {
        "encoding": "inplace",
        "label": "uint32",
        "numberOfBytes": "4"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      }
    }
  }
}